{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A Docker client for Python, designed to be fun and intuitive!</p> <p>Works on Linux, macOS and Windows, for Python 3.8 and above. </p> <ul> <li>Documentation</li> <li>Github repository</li> </ul>"},{"location":"#how-to-install","title":"How to install?","text":"<pre><code>pip install python-on-whales\n</code></pre>"},{"location":"#some-cool-examples","title":"Some cool examples","text":"<p>Start by doing</p> <pre><code>from python_on_whales import docker\n</code></pre> <p>and then:</p> <ul> <li><code>docker run hello-world</code> -&gt; <code>docker.run(\"hello-world\")</code></li> <li><code>docker pull ubuntu</code> -&gt; <code>docker.pull(\"ubuntu\")</code></li> <li><code>docker build ./</code> -&gt; <code>docker.build(\"./\")</code></li> <li><code>docker compose up my_service</code> -&gt; <code>docker.compose.up([\"my_service\"])</code></li> <li><code>docker image ls</code> -&gt; <code>docker.image.list()</code></li> <li><code>docker ps</code> -&gt; <code>docker.ps()</code></li> <li><code>docker cp</code> -&gt; <code>docker.copy()</code></li> </ul> <p>You get the idea \ud83d\ude42 it's the same as the CLI we all know and love.</p> <pre><code>&gt;&gt;&gt; from python_on_whales import docker\n\n&gt;&gt;&gt; output = docker.run(\"hello-world\")\n&gt;&gt;&gt; print(output)\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\n...\n</code></pre> <pre><code>&gt;&gt;&gt; from python_on_whales import docker\n&gt;&gt;&gt; print(docker.run(\"nvidia/cuda:11.0-base\", [\"nvidia-smi\"], gpus=\"all\"))\n+-----------------------------------------------------------------------------+\n| NVIDIA-SMI 450.51.06    Driver Version: 450.51.06    CUDA Version: 11.0     |\n|-------------------------------+----------------------+----------------------+\n| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |\n| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |\n|                               |                      |               MIG M. |\n|===============================+======================+======================|\n|   0  Tesla T4            On   | 00000000:00:1E.0 Off |                    0 |\n| N/A   34C    P8     9W /  70W |      0MiB / 15109MiB |      0%      Default |\n|                               |                      |                  N/A |\n+-------------------------------+----------------------+----------------------+\n\n+-----------------------------------------------------------------------------+\n| Processes:                                                                  |\n|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |\n|        ID   ID                                                   Usage      |\n|=============================================================================|\n|  No running processes found                                                 |\n+-----------------------------------------------------------------------------+\n</code></pre> <pre><code>&gt;&gt;&gt; from python_on_whales import docker\n&gt;&gt;&gt; my_docker_image = docker.pull(\"ubuntu:20.04\")\n20.04: Pulling from library/ubuntu\ne6ca3592b144: Downloading [=============&gt;                                     ]  7.965MB/28.56MB\n534a5505201d: Download complete\n990916bd23bb: Download complete\n\n&gt;&gt;&gt; print(my_docker_image.repo_tags)\n['ubuntu:20.04']\n\n&gt;&gt;&gt; docker.image.list()\n[python_on_whales.Image(id='sha256:1a437e363abfa', tags=['ubuntu:20.04'])]\n\n&gt;&gt;&gt; my_docker_image.remove()\n</code></pre> <pre><code>&gt;&gt;&gt; from python_on_whales import docker\n&gt;&gt;&gt; my_image = docker.build(\".\", tags=\"some_name\")  # uses Buildx/buildkit by default\n[+] Building 1.6s (17/17) FINISHED\n =&gt; [internal] load build definition from Dockerfile                                                            0.0s\n =&gt; =&gt; transferring dockerfile: 32B                                                                             0.0s\n =&gt; [internal] load .dockerignore                                                                               0.0s\n =&gt; =&gt; transferring context: 2B                                                                                 0.0s\n =&gt; [internal] load metadata for docker.io/library/python:3.6                                                   1.4s\n =&gt; [python_dependencies 1/5] FROM docker.io/library/python:3.6@sha256:29328c59adb9ee6acc7bea8eb86d0cb14033c85  0.0s\n =&gt; [internal] load build context                                                                               0.1s\n =&gt; =&gt; transferring context: 72.86kB                                                                            0.0s\n =&gt; CACHED [python_dependencies 2/5] RUN pip install typeguard pydantic requests tqdm                           0.0s\n =&gt; CACHED [python_dependencies 3/5] COPY tests/test-requirements.txt /tmp/                                     0.0s\n =&gt; CACHED [python_dependencies 4/5] COPY requirements.txt /tmp/                                                0.0s\n =&gt; CACHED [python_dependencies 5/5] RUN pip install -r /tmp/test-requirements.txt -r /tmp/requirements.txt     0.0s\n =&gt; CACHED [tests_ubuntu_install_without_buildx 1/7] RUN apt-get update &amp;&amp;     apt-get install -y       apt-tr  0.0s\n =&gt; CACHED [tests_ubuntu_install_without_buildx 2/7] RUN curl -fsSL https://download.docker.com/linux/ubuntu/g  0.0s\n =&gt; CACHED [tests_ubuntu_install_without_buildx 3/7] RUN add-apt-repository    \"deb [arch=amd64] https://downl  0.0s\n =&gt; CACHED [tests_ubuntu_install_without_buildx 4/7] RUN  apt-get update &amp;&amp;      apt-get install -y docker-ce-  0.0s\n =&gt; CACHED [tests_ubuntu_install_without_buildx 5/7] WORKDIR /python-on-whales                                  0.0s\n =&gt; CACHED [tests_ubuntu_install_without_buildx 6/7] COPY . .                                                   0.0s\n =&gt; CACHED [tests_ubuntu_install_without_buildx 7/7] RUN pip install -e .                                       0.0s\n =&gt; exporting to image                                                                                          0.1s\n =&gt; =&gt; exporting layers                                                                                         0.0s\n =&gt; =&gt; writing image sha256:e1c2382d515b097ebdac4ed189012ca3b34ab6be65ba0c650421ebcac8b70a4d                    0.0s\n =&gt; =&gt; naming to docker.io/library/some_image_name\n</code></pre>"},{"location":"#some-more-dockerrun-advanced-examples-with-postgres","title":"Some more <code>docker.run()</code> advanced examples with postgres","text":"<pre><code>docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres\n</code></pre> <p>becomes</p> <pre><code>from python_on_whales import docker\n\ndocker.run(\n    \"postgres:9.6\",\n    name=\"some-postgres\",\n    envs={\"POSTGRES_PASSWORD\": \"mysecretpassword\"},\n    detach=True,\n)\nprint(docker.ps())\n# [python_on_whales.Container(id='f5fb939c409d', name='some-postgres')]\n</code></pre> <pre><code>docker run -it --rm --network some-network postgres psql -h some-postgres -U postgres\n</code></pre> <p>becomes</p> <pre><code>from python_on_whales import docker\n\n# since it's interactive, you'll be dropped into the psql shell. The python code\n# will continue only after you exit the shell.\ndocker.run(\n    \"postgres:9.6\",\n    [\"psql\", \"-h\", \"some-postgres\", \"-U\", \"postgres\"],\n    networks=[\"some-network\"],\n    interactive=True,\n    tty=True,\n    remove=True,\n)\n</code></pre> <pre><code>docker run -d --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -e PGDATA=/var/lib/postgresql/data/pgdata -v /custom/mount:/var/lib/postgresql/data -v myvolume:/tmp/myvolume postgres -c shared_buffers=256MB -c max_connections=200\n</code></pre> <p>becomes</p> <pre><code>from python_on_whales import docker\n\ndocker.run(\n    \"postgres:9.6\",\n    [\"-c\", \"shared_buffers=256MB\", \"-c\", \"max_connections=200\"],\n    name=\"some-postgres\",\n    envs={\"POSTGRES_PASSWORD\": \"mysecretpassword\", \"PGDATA\": \"/var/lib/postgresql/data/pgdata\"},\n    volumes=[(\"/custom/mount\", \"/var/lib/postgresql/data\"), (\"myvolume\", \"/tmp/myvolume\")],\n    detach=True,\n)\n</code></pre>"},{"location":"#main-features","title":"Main features","text":"<ul> <li>1 to 1 mapping between the CLI interface and the Python API. No need to look in the docs what is the name of the function/argument you need.</li> <li>Support for the latest Docker features:  Docker buildx/buildkit,  <code>docker run --gpu=all ...</code></li> <li>Support for Docker stack, services and Swarm (same API as the command line).</li> <li>Progress bars and progressive outputs when pulling, pushing, loading, building...</li> <li>Support for some other CLI commands that are not in Docker-py:  <code>docker cp</code>, <code>docker run --cpus ...</code> and more.</li> <li>Nice SSH support for remote daemons.</li> <li>Docker object as Python objects: Container, Images, Volumes, Services... and their attributes are updated in real-time!</li> <li>Each Docker object can be used as a context manager. When getting out of the  context, the Docker object is removed automatically, even if an exception occurs.</li> <li>A fully typed API (Mypy and IDE-friendly) compatible with <code>pathlib</code> and <code>os.path</code></li> <li>All Docker objects and the Docker client are safe to use with multithreading and multiprocessing.</li> <li>Display the commands called and the environment variables used by setting the environment variable <code>PYTHON_ON_WHALES_DEBUG=1</code>.</li> </ul>"},{"location":"#why-another-project-why-not-build-on-docker-py","title":"Why another project? Why not build on Docker-py?","text":"<p>In a sense this project is built on top of Docker-py  because the implementation, the organisation and the API is inspired from the project, but the codebases  could not be the same.</p> <p>Two major differences do not permit that:</p> <p>1) The API is quite different. The aim of Python on Whales is to provide a 1-to-1  mapping between the Docker command line and Python, so that users don't even have  to open the docs to do write code.</p> <p>2) While Docker-py is a complete re-implementation of the Docker client binary  (written in Go), Python on whales sits on top of the Docker client binary, which makes  implementing new features much easier and safer. For example, it's  unlikely that docker-py supports Buildx/buildkit anytime soon because rewriting a large Go codebase in Python is hard work.</p> <p></p>"},{"location":"#should-i-use-docker-py-or-python-on-whales","title":"Should I use Docker-py or Python on Whales?","text":"<p>Well, it's written in each project's description!</p> <ul> <li>Docker-py: A Python library for the Docker Engine API</li> <li>Python on whales: An awesome Python wrapper for an awesome Docker CLI</li> </ul> <p>If you need to talk to the Docker engine directly, you need to do low level operations, use docker-py. Some good example would be writing the code to control docker from an IDE,  or if the speed of Docker calls is very important.  If you don't want to depend on the Docker CLI binary (~50MB), use docker-py.</p> <p>If you wanted to call the docker command line from Python,  do high level operations, use Python on Whales. For example if you want to write your CI logic in Python rather than in bash (a very good choice \ud83d\ude09). Some commands are only available in Python on whales  too: <code>docker.buildx.build(...)</code>, <code>docker.stack.deploy(...)</code>...</p> <p>Use the right tool for the right job \ud83d\ude42</p>"},{"location":"#alternatives-to-docker-podman-nerdctl","title":"Alternatives to Docker: Podman, nerdctl...","text":"<p>Support for Docker-compatible clients like Podman and Nerdctl was introduced in Python-on-whales version 0.44.0.</p> <p>You can use an arbitrary binary to execute Docker commands by using the argument <code>client_call</code> of <code>python_on_whales.DockerCLient</code>. Here is an example:</p> <pre><code>&gt;&gt;&gt; from python_on_whales import DockerClient\n\n&gt;&gt;&gt; nerdctl = DockerClient(client_call=[\"nerdctl\"])\n\n&gt;&gt;&gt; nerdctl.pull(\"python:3.9\")\ndocker.io/library/python:3.9:                                                     resolved       |++++++++++++++++++++++++++++++++++++++|\nindex-sha256:a83c0aa6471527636d7331c30704d0f88e0ab3331bbc460d4ae2e53bbae64dca:    done           |++++++++++++++++++++++++++++++++++++++|\nmanifest-sha256:8ccef93ff3c9e1bb9562d394526cdc6834033a0498073d41baa8b309f4fac20e: done           |++++++++++++++++++++++++++++++++++++++|\nconfig-sha256:f033692e2c5abe1e0ee34bcca759a3e4432b10b0031174b08d48bcc90d14d68b:   done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:9952b1051adaff513c99f86765361450af108b12b0073d0ba40255c4e419b481:    done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:c766e27afb21eddf9ab3e4349700ebe697c32a4c6ada6af4f08282277a291a28:    done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:1535e3c1181a81ea66d5bacb16564e4da2ba96304506598be39afe9c82b21c5c:    done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:6de7cb7bdc8f9b4c4d6539233fe87304aa1a6427c3238183265c9f02d831eddb:    done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:967757d5652770cfa81b6cc7577d65e06d336173da116d1fb5b2d349d5d44127:    done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:c357e2c68cb3bf1e98dcb3eb6ceb16837253db71535921d6993c594588bffe04:    done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:26787c68cf0c92a778db814d327e283fe1da4434a7fea1f0232dae8002e38f33:    done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:6aefca2dc61dcbcd268b8a9861e552f9cdb69e57242faec64ac120d2355a9c1a:    done           |++++++++++++++++++++++++++++++++++++++|\nlayer-sha256:32a180f5cf85702e7680719c40c39c07972b1176355df5a621de9eb87ad07ce2:    done           |++++++++++++++++++++++++++++++++++++++|\nelapsed: 35.9s                                                                    total:  333.5  (9.3 MiB/s)\n\npython_on_whales.Image(id='sha256:f033692e2c5ab', tags=['python:3.9'])\n</code></pre> <p>You can do something similar with podman:</p> <pre><code>from python_on_whales import DockerClient\n\npodman = DockerClient(client_call=[\"podman\"])\n\npodman.pull(\"hello-world\")\npodman.run(\"hello-world\")\nprint(podman.ps())\n...\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Any and all PRs are welcome. Please see this documentation.</p>"},{"location":"#what-about-the-license","title":"What about the license?","text":"<p>It's a MIT license, so quite permissive.</p> <p>The license can be found in the git repository.</p>"},{"location":"docker_client/","title":"The Docker client object","text":""},{"location":"docker_client/#python_on_whales.docker_client.DockerClient","title":"DockerClient","text":"<p>Creates a Docker client</p> <p>Note that</p> <pre><code>from python_on_whales import docker\nprint(docker.run(\"hello-world\"))\n</code></pre> <p>is equivalent to</p> <pre><code>from python_on_whales import DockerClient\ndocker = DockerClient()\nprint(docker.run(\"hello-world\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[ValidPath]</code> <p>Location of client config files (default \"~/.docker\")</p> <code>None</code> <code>context</code> <code>Optional[str]</code> <p>Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with \"docker context use\")</p> <code>None</code> <code>debug</code> <code>Optional[bool]</code> <p>Enable debug mode</p> <code>None</code> <code>host</code> <code>Optional[str]</code> <p>Daemon socket(s) to connect to</p> <code>None</code> <code>log_level</code> <code>Optional[str]</code> <p>Set the logging level (\"debug\"|\"info\"|\"warn\"|\"error\"|\"fatal\") (default \"info\")</p> <code>None</code> <code>tls</code> <code>Optional[bool]</code> <p>Use TLS; implied by <code>tlsverify</code></p> <code>None</code> <code>tlscacert</code> <code>Optional[ValidPath]</code> <p>Trust certs signed only by this CA (default \"~/.docker/ca.pem\")</p> <code>None</code> <code>compose_files</code> <code>List[ValidPath]</code> <p>Docker compose yaml file</p> <code>[]</code> <code>compose_profiles</code> <code>List[str]</code> <p>List of compose profiles to use. Take a look at the documentation for profiles.</p> <code>[]</code> <code>compose_env_file</code> <code>Optional[ValidPath]</code> <p>.env file containing the environments variables to inject into the compose project. By default, it uses <code>./.env</code>.</p> <code>None</code> <code>compose_project_name</code> <code>Optional[str]</code> <p>The name of the compose project. It will be prefixed to networks, volumes and containers created by compose.</p> <code>None</code> <code>compose_project_directory</code> <code>Optional[ValidPath]</code> <p>Use an alternate working directory. By default, it uses the path of the compose file.</p> <code>None</code> <code>compose_compatibility</code> <code>Optional[bool]</code> <p>Use docker compose in compatibility mode.</p> <code>None</code> <code>client_call</code> <code>List[str]</code> <p>Client binary to use and how to call it. Default is <code>[\"docker\"]</code>. You can try with for example <code>[\"podman\"]</code> or <code>[\"nerdctl\"]</code>. The client must have the same commands and outputs as Docker to work. Some best effort support is done in case of divergences, meaning you can report issues occuring on some other binary than Docker, but we don't guarantee that it will be fixed. This option is a list because you can provide a list of command line arguments to be placed after <code>\"docker\"</code>. For exemple <code>host=\"ssh://my_user@host.com\"</code> is equivalent to <code>client_call=[\"docker\", \"--host=ssh://my_user@host.com\"]</code>. This will allow you to use some exotic options that are not explicitly supported by Python-on-whales. Let's say you want to use estargz to run a container immediately, without waiting for the \"pull\" to finish (yes it's possible!), you can do <code>nerdctl = DockerClient(client_call=[\"nerdctl\", \"--snapshotter=stargz\"])</code> and then <code>nerdctl.run(\"ghcr.io/stargz-containers/python:3.7-org\", [\"-c\", \"print('hi')\"])</code>. You can also use this system to call Docker with sudo with <code>client_call=[\"sudo\", \"docker\"]</code> (note that it won't ask for your password, so sudo should be passwordless during the python program execution).</p> <code>['docker']</code> <code>client_binary</code> <code>str</code> <p>Deprecated, use <code>client_call</code>. If you used before <code>client_binary=\"podman\"</code>, now use <code>client_call=[\"podman\"]</code>.</p> <code>'docker'</code>"},{"location":"docker_client/#python_on_whales.docker_client.DockerClient.login","title":"login","text":"<pre><code>login(server=None, username=None, password=None)\n</code></pre> <p>Log in to a Docker registry.</p> <p>If no server is specified, the default is defined by the daemon.</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>Optional[str]</code> <p>The server to log into. For example, with a self-hosted registry it might be something like <code>server=\"192.168.0.10:5000\"</code></p> <code>None</code> <code>username</code> <code>Optional[str]</code> <p>The username</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>The password</p> <code>None</code>"},{"location":"docker_client/#python_on_whales.docker_client.DockerClient.login_ecr","title":"login_ecr","text":"<pre><code>login_ecr(aws_access_key_id=None, aws_secret_access_key=None, region_name=None, registry=None)\n</code></pre> <p>Login to the aws ECR registry. Credentials are taken from the environment variables as defined in the aws docs.</p> <p>If you don't have a profile or your environment variables configured, you can also use the function arguments <code>aws_access_key_id</code>, <code>aws_secret_access_key</code>, <code>region_name</code>.</p> <p>Behind the scenes, those arguments are passed directly to</p> <pre><code>botocore.session.get_session().create_client(...)\n</code></pre> <p>You need botocore to run this function. Use <code>pip install botocore</code> to install it.</p> <p>The <code>registry</code> parameter can be used to override the registry that is guessed from the authorization token request's response. In other words: If the registry is <code>None</code> (the default) then it will be assumed that it's the ECR registry linked to the credentials provided. It is especially useful if the aws account you use can access several repositories and you need to explicitly define the one you want to use</p>"},{"location":"docker_client/#python_on_whales.docker_client.DockerClient.logout","title":"logout","text":"<pre><code>logout(server=None)\n</code></pre> <p>Logout from a Docker registry</p> <p>Parameters:</p> Name Type Description Default <code>server</code> <code>Optional[str]</code> <p>The server to logout from. For example, with a self-hosted registry it might be something like <code>server=\"192.168.0.10:5000\"</code></p> <code>None</code>"},{"location":"docker_client/#python_on_whales.docker_client.DockerClient.version","title":"version","text":"<pre><code>version()\n</code></pre> <p>Not yet implemented</p>"},{"location":"docker_client/#sub-commands","title":"Sub-commands","text":"<ul> <li><code>docker.buildx</code></li> <li><code>docker.compose</code></li> <li><code>docker.config</code></li> <li><code>docker.container</code></li> <li><code>docker.context</code></li> <li><code>docker.image</code></li> <li><code>docker.manifest</code></li> <li><code>docker.network</code></li> <li><code>docker.node</code></li> <li><code>docker.secret</code></li> <li><code>docker.service</code></li> <li><code>docker.stack</code></li> <li><code>docker.swarm</code></li> <li><code>docker.system</code></li> <li><code>docker.trust</code></li> <li><code>docker.volume</code></li> </ul>"},{"location":"docker_client/#other-commands","title":"Other commands","text":"<p>They're actually aliases</p> <ul> <li><code>docker.attach</code></li> <li><code>docker.build</code></li> <li><code>docker.commit</code></li> <li><code>docker.copy</code></li> <li><code>docker.create</code></li> <li><code>docker.diff</code></li> <li><code>docker.execute</code></li> <li><code>docker.export</code></li> <li><code>docker.images</code></li> <li><code>docker.import_</code></li> <li><code>docker.info</code></li> <li><code>docker.kill</code></li> <li><code>docker.load</code></li> <li><code>docker.logs</code></li> <li><code>docker.pause</code></li> <li><code>docker.ps</code></li> <li><code>docker.pull</code></li> <li><code>docker.push</code></li> <li><code>docker.rename</code></li> <li><code>docker.restart</code></li> <li><code>docker.remove</code></li> <li><code>docker.run</code></li> <li><code>docker.save</code></li> <li><code>docker.start</code></li> <li><code>docker.stats</code></li> <li><code>docker.stop</code></li> <li><code>docker.tag</code></li> <li><code>docker.top</code></li> <li><code>docker.unpause</code></li> <li><code>docker.update</code></li> <li><code>docker.wait</code></li> </ul>"},{"location":"docker_client/#about-multithreading-and-multiprocessing","title":"About multithreading and multiprocessing","text":"<p>Behind the scenes, Python on whales calls the Docker command line interface with subprocess. The Python on whales client does not store any intermediate state so it's safe  to use with multithreading. </p> <p>The Docker objects store some intermediate states (the attributes  that you would normally get with <code>docker ... inspect</code>but no logic in  the codebase depends on those attributes. They're just here so that users can look at them.  So you can share them between process/threads and pickle containers, images, networks...</p> <p>The Docker daemon works with its own objects internally and handles concurrent and conflicting requests.  For example, if you create two containers with the same name from different threads, only one will  succeed. If you pull the same docker image from multiple processes/threads, the Docker daemon will  only pull the image and layers once.</p> <p>Just be careful with some scenario similar to this one</p> <pre><code>Thread 1: my_container = docker.run(..., detach=True)\n...\n# my_container finishes\n...\nThread 2: docker.container.prune()\n...\nThread 1: docker.logs(my_container)  # will fail because the container was removed by thread 2\n</code></pre> <p>In the end, unless you use this type of logic in your code,  Python-on-whales is safe to use with multithreading and multiprocessing.</p>"},{"location":"docker_client/#the-docker-cli","title":"The Docker CLI","text":"<p>Python-on-whales needs the Docker CLI to work (unlike docker-py). Most of the time, users already have the CLI installed on their machines. It's possible to  verify that the CLI is there by doing <code>docker --help</code> in the command line.</p> <p>Sometimes, the CLI might not be available on the system, it can happen if you want to control Docker from within a container with <code>-v /var/run/docker.sock:/var/run/docker.sock</code>, or if you want to connect to a remote daemon with the <code>host</code> argument.</p> <p>In this case, when using python-on-whales, the CLI will be downloaded automatically  (it's a single binary), and will be put in </p> <pre><code>pathlib.Path.home() / \".cache/python-on-whales/docker\"\n</code></pre> <p>Since it's not in the PATH and was not downloaded with the package manager, it's only seen and  used by python-on-whales.</p> <p>If you want to trigger the download manually (to avoid downloading the CLI at runtime), you can run from your shell:</p> <pre><code>python-on-whales download-cli\n</code></pre>"},{"location":"docker_client/#handling-an-unavailable-client","title":"Handling an unavailable client","text":"<p>Trying to use Python-on-whales when it cannot find or download a Docker client binary will trigger a <code>python_on_whales.ClientNotFoundError</code>. You can use a try-except around  a first <code>docker.ps()</code> call to handle the case when Python-on-whales won't work.</p>"},{"location":"docker_objects/builders/","title":"Docker builders","text":"<p>The Buildx builders objects.</p> <p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_builder = docker.buildx.inspect(\"my-builder\")\n\n# or\n\nmy_builder = docker.buildx.create()\n\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import Builder\n</code></pre>"},{"location":"docker_objects/builders/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker buildx inspect ...</code></p> <p>Only a few are available at the moment</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: my_builder = docker.buildx.create()\n\nIn [4]: def super_print(obj):\n   ...:     print(f\"type={type(obj)}, value={obj}\")\n   ...:\n\nIn [4]: super_print(builder.name)\ntype = &lt;class 'str'&gt;, value = funny_mclean\n\nIn [5]: super_print(builder.driver)\ntype = &lt;class 'str'&gt;, value = docker-container\n\n</code></pre>"},{"location":"docker_objects/builders/#methods","title":"Methods","text":""},{"location":"docker_objects/builders/#python_on_whales.Builder","title":"Builder","text":""},{"location":"docker_objects/builders/#python_on_whales.components.buildx.cli_wrapper.Builder.remove","title":"remove","text":"<pre><code>remove()\n</code></pre> <p>Removes this builder. After this operation the builder cannot be used anymore.</p> <p>If you use the builder as a context manager, it will call this function when you exit the context manager.</p> <pre><code>from python_on_whales import docker\n\nbuildx_builder = docker.buildx.create(use=True)\nwith buildx_builder:\n    docker.build(\".\")\n\n# now the variable buildx_builder is not usable since we're out of the context manager.\n# the .remove() method was called behind the scenes\n# since it was the current builder, 'default' is now the current builder.\n</code></pre>"},{"location":"docker_objects/configs/","title":"Docker configs","text":"<p>Configs objects present in Swarm mode</p> <p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_config = docker.config.inspect(\"my-config-name\")\n\n# or\n\nmy_config = docker.config.create(\"my_config_name\", \"my_config_file\")\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import Config\n\ndef print_config_labels(config: Config):\n    print(config.spec.labels)\n</code></pre>"},{"location":"docker_objects/configs/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker config inspect ...</code></p> <p>To get a complete description of those attributes, you  can take a look at the daemon api reference page  and click on \"200 No error\".</p> <p>An example is worth many lines of descriptions.</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: config = docker.config.create(\"my_config\", \"./config_file.cfg\", labels=dict(hello=\"world\"))\n\nIn [3]: def super_print(obj):\n   ...:     print(f\"type={type(obj)}, value={obj}\")\n   ...:\n\nIn [4]: super_print(config.id)\ntype = &lt;class 'str'&gt;, value = 3j6611yenihg2zstto81dksw2\n\nIn [5]: super_print(config.version.index)\ntype = &lt;class 'int'&gt;, value = 11\n\nIn [6]: super_print(config.created_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:48:56.231426+00:00\n\nIn [7]: super_print(config.updated_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:48:56.231426+00:00\n\nIn [8]: super_print(config.spec.name)\ntype = &lt;class 'str'&gt;, value = my_config\n\nIn [9]: super_print(config.spec.labels)\ntype = &lt;class 'dict'&gt;, value = {'hello': 'world'}\n\nIn [10]: super_print(config.spec.data)\ntype = &lt;class 'str'&gt;, value = SGVsbG8gd29ybGQh\n\nIn [11]: super_print(config.spec.templating)\ntype = &lt;class 'NoneType'&gt;, value = None\n\n</code></pre>"},{"location":"docker_objects/configs/#methods","title":"Methods","text":""},{"location":"docker_objects/configs/#python_on_whales.Config","title":"Config","text":""},{"location":"docker_objects/configs/#python_on_whales.components.config.cli_wrapper.Config.remove","title":"remove","text":"<pre><code>remove()\n</code></pre> <p>Remove this config.</p> <p>Note that you can also use a <code>python_on_whales.Config</code> as a context manager to ensure it's removed even if an exception occurs.</p>"},{"location":"docker_objects/containers/","title":"Docker containers","text":"<p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_container = docker.container.inspect(\"my-container-name\")\n\n# for example:\nif my_container.state.running:\n    my_container.kill()\n\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import Container\n\ndef print_dodo(container: Container):\n    print(container.execute([\"echo\", \"dodo\"]))\n</code></pre>"},{"location":"docker_objects/containers/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker container inspect ...</code></p> <p>If you want to know the exact structure, you can go to the  <code>docker container inspect</code> reference page and click on \"200 no error\". An example is worth many lines of descriptions.</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: container = docker.run(\"ubuntu\", [\"sleep\", \"infinity\"], detach=True)\n\nIn [4]: def super_print(obj):\n   ...:     print(f\"type={type(obj)}, value={obj}\")\n   ...:\n\nIn [4]: super_print(container.id)\ntype = &lt;class 'str'&gt;, value = 613fdcc2c35013aae763ab3477653d52a52820b57cea6b5395ae9141ffc96608\n\nIn [5]: super_print(container.created)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:49:11.145922+00:00\n\nIn [6]: super_print(container.path)\ntype = &lt;class 'str'&gt;, value = sleep\n\nIn [7]: super_print(container.args)\ntype = &lt;class 'list'&gt;, value = ['infinity']\n\nIn [8]: super_print(container.state.status)\ntype = &lt;class 'str'&gt;, value = running\n\nIn [9]: super_print(container.state.running)\ntype = &lt;class 'bool'&gt;, value = True\n\nIn [10]: super_print(container.state.paused)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [11]: super_print(container.state.restarting)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [12]: super_print(container.state.oom_killed)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [13]: super_print(container.state.dead)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [14]: super_print(container.state.pid)\ntype = &lt;class 'int'&gt;, value = 2666\n\nIn [15]: super_print(container.state.exit_code)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [16]: super_print(container.state.error)\ntype = &lt;class 'str'&gt;, value = \n\nIn [17]: super_print(container.state.started_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:49:11.376266+00:00\n\nIn [18]: super_print(container.state.finished_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 0001-01-01 00:00:00+00:00\n\nIn [19]: super_print(container.state.health)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [20]: super_print(container.image)\ntype = &lt;class 'str'&gt;, value = sha256:1f6ddc1b2547b2e38dc25b265ac585238a3c23da63976722864dab2a069c74f4\n\nIn [21]: super_print(container.resolv_conf_path)\ntype = &lt;class 'str'&gt;, value = /var/lib/docker/containers/613fdcc2c35013aae763ab3477653d52a52820b57cea6b5395ae9141ffc96608/resolv.conf\n\nIn [22]: super_print(container.hostname_path)\ntype = &lt;class 'pathlib.PosixPath'&gt;, value = /var/lib/docker/containers/613fdcc2c35013aae763ab3477653d52a52820b57cea6b5395ae9141ffc96608/hostname\n\nIn [23]: super_print(container.hosts_path)\ntype = &lt;class 'pathlib.PosixPath'&gt;, value = /var/lib/docker/containers/613fdcc2c35013aae763ab3477653d52a52820b57cea6b5395ae9141ffc96608/hosts\n\nIn [24]: super_print(container.log_path)\ntype = &lt;class 'pathlib.PosixPath'&gt;, value = /var/lib/docker/containers/613fdcc2c35013aae763ab3477653d52a52820b57cea6b5395ae9141ffc96608/613fdcc2c35013aae763ab3477653d52a52820b57cea6b5395ae9141ffc96608-json.log\n\nIn [25]: super_print(container.node)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [26]: super_print(container.name)\ntype = &lt;class 'str'&gt;, value = keen_margulis\n\nIn [27]: super_print(container.restart_count)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [28]: super_print(container.driver)\ntype = &lt;class 'str'&gt;, value = overlay2\n\nIn [29]: super_print(container.platform)\ntype = &lt;class 'str'&gt;, value = linux\n\nIn [30]: super_print(container.mount_label)\ntype = &lt;class 'str'&gt;, value = \n\nIn [31]: super_print(container.process_label)\ntype = &lt;class 'str'&gt;, value = \n\nIn [32]: super_print(container.app_armor_profile)\ntype = &lt;class 'str'&gt;, value = docker-default\n\nIn [33]: super_print(container.exec_ids)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [34]: super_print(container.host_config.cpu_shares)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [35]: super_print(container.host_config.memory)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [36]: super_print(container.host_config.cgroup_parent)\ntype = &lt;class 'pathlib.PosixPath'&gt;, value = .\n\nIn [37]: super_print(container.host_config.blkio_weight)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [38]: super_print(container.host_config.blkio_weight_device)\ntype = &lt;class 'list'&gt;, value = []\n\nIn [39]: super_print(container.host_config.blkio_device_read_bps)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [40]: super_print(container.host_config.blkio_device_write_bps)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [41]: super_print(container.host_config.blkio_device_read_iops)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [42]: super_print(container.host_config.blkio_device_write_iops)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [43]: super_print(container.host_config.cpu_period)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [44]: super_print(container.host_config.cpu_quota)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [45]: super_print(container.host_config.cpu_realtime_period)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [46]: super_print(container.host_config.cpu_realtime_runtime)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [47]: super_print(container.host_config.cpuset_cpus)\ntype = &lt;class 'str'&gt;, value = \n\nIn [48]: super_print(container.host_config.cpuset_mems)\ntype = &lt;class 'str'&gt;, value = \n\nIn [49]: super_print(container.host_config.devices)\ntype = &lt;class 'list'&gt;, value = []\n\nIn [50]: super_print(container.host_config.device_cgroup_rules)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [51]: super_print(container.host_config.device_requests)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [52]: super_print(container.host_config.kernel_memory)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [53]: super_print(container.host_config.kernel_memory_tcp)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [54]: super_print(container.host_config.memory_reservation)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [55]: super_print(container.host_config.memory_swap)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [56]: super_print(container.host_config.memory_swappiness)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [57]: super_print(container.host_config.nano_cpus)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [58]: super_print(container.host_config.oom_kill_disable)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [59]: super_print(container.host_config.init)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [60]: super_print(container.host_config.pids_limit)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [61]: super_print(container.host_config.ulimits)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [62]: super_print(container.host_config.cpu_count)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [63]: super_print(container.host_config.cpu_percent)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [64]: super_print(container.host_config.binds)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [65]: super_print(container.host_config.container_id_file)\ntype = &lt;class 'pathlib.PosixPath'&gt;, value = .\n\nIn [66]: super_print(container.host_config.log_config.type)\ntype = &lt;class 'str'&gt;, value = json-file\n\nIn [67]: super_print(container.host_config.log_config.config)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [68]: super_print(container.host_config.network_mode)\ntype = &lt;class 'str'&gt;, value = default\n\nIn [69]: super_print(container.host_config.port_bindings)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [70]: super_print(container.host_config.restart_policy.name)\ntype = &lt;class 'str'&gt;, value = no\n\nIn [71]: super_print(container.host_config.restart_policy.maximum_retry_count)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [72]: super_print(container.host_config.auto_remove)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [73]: super_print(container.host_config.volume_driver)\ntype = &lt;class 'str'&gt;, value = \n\nIn [74]: super_print(container.host_config.volumes_from)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [75]: super_print(container.host_config.mounts)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [76]: super_print(container.host_config.capabilities)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [77]: super_print(container.host_config.cap_add)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [78]: super_print(container.host_config.cap_drop)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [79]: super_print(container.host_config.dns)\ntype = &lt;class 'list'&gt;, value = []\n\nIn [80]: super_print(container.host_config.dns_options)\ntype = &lt;class 'list'&gt;, value = []\n\nIn [81]: super_print(container.host_config.dns_search)\ntype = &lt;class 'list'&gt;, value = []\n\nIn [82]: super_print(container.host_config.extra_hosts)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [83]: super_print(container.host_config.group_add)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [84]: super_print(container.host_config.ipc_mode)\ntype = &lt;class 'str'&gt;, value = private\n\nIn [85]: super_print(container.host_config.cgroup)\ntype = &lt;class 'str'&gt;, value = \n\nIn [86]: super_print(container.host_config.links)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [87]: super_print(container.host_config.oom_score_adj)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [88]: super_print(container.host_config.pid_mode)\ntype = &lt;class 'str'&gt;, value = \n\nIn [89]: super_print(container.host_config.privileged)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [90]: super_print(container.host_config.publish_all_ports)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [91]: super_print(container.host_config.readonly_rootfs)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [92]: super_print(container.host_config.security_opt)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [93]: super_print(container.host_config.storage_opt)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [94]: super_print(container.host_config.tmpfs)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [95]: super_print(container.host_config.uts_mode)\ntype = &lt;class 'str'&gt;, value = \n\nIn [96]: super_print(container.host_config.userns_mode)\ntype = &lt;class 'str'&gt;, value = \n\nIn [97]: super_print(container.host_config.shm_size)\ntype = &lt;class 'int'&gt;, value = 67108864\n\nIn [98]: super_print(container.host_config.sysctls)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [99]: super_print(container.host_config.runtime)\ntype = &lt;class 'str'&gt;, value = runc\n\nIn [100]: super_print(container.host_config.console_size)\ntype = &lt;class 'tuple'&gt;, value = (0, 0)\n\nIn [101]: super_print(container.host_config.isolation)\ntype = &lt;class 'str'&gt;, value = \n\nIn [102]: super_print(container.host_config.masked_paths)\ntype = &lt;class 'list'&gt;, value = [PosixPath('/proc/asound'), PosixPath('/proc/acpi'), PosixPath('/proc/kcore'), PosixPath('/proc/keys'), PosixPath('/proc/latency_stats'), PosixPath('/proc/timer_list'), PosixPath('/proc/timer_stats'), PosixPath('/proc/sched_debug'), PosixPath('/proc/scsi'), PosixPath('/sys/firmware')]\n\nIn [103]: super_print(container.host_config.readonly_paths)\ntype = &lt;class 'list'&gt;, value = [PosixPath('/proc/bus'), PosixPath('/proc/fs'), PosixPath('/proc/irq'), PosixPath('/proc/sys'), PosixPath('/proc/sysrq-trigger')]\n\nIn [104]: super_print(container.graph_driver.name)\ntype = &lt;class 'str'&gt;, value = overlay2\n\nIn [105]: super_print(container.graph_driver.data)\ntype = &lt;class 'dict'&gt;, value = {'LowerDir': '/var/lib/docker/overlay2/e21342a3f719cc966d01df258973661d39c0febd0646b11cfc8eac360a3a382c-init/diff:/var/lib/docker/overlay2/c1fad715706fbfc8dc2086a0e8a20c28c22eb8f82a07710e78990c035dc02cab/diff', 'MergedDir': '/var/lib/docker/overlay2/e21342a3f719cc966d01df258973661d39c0febd0646b11cfc8eac360a3a382c/merged', 'UpperDir': '/var/lib/docker/overlay2/e21342a3f719cc966d01df258973661d39c0febd0646b11cfc8eac360a3a382c/diff', 'WorkDir': '/var/lib/docker/overlay2/e21342a3f719cc966d01df258973661d39c0febd0646b11cfc8eac360a3a382c/work'}\n\nIn [106]: super_print(container.size_rw)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [107]: super_print(container.size_root_fs)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [108]: super_print(container.mounts)\ntype = &lt;class 'list'&gt;, value = []\n\nIn [109]: super_print(container.config.hostname)\ntype = &lt;class 'str'&gt;, value = 613fdcc2c350\n\nIn [110]: super_print(container.config.domainname)\ntype = &lt;class 'str'&gt;, value = \n\nIn [111]: super_print(container.config.user)\ntype = &lt;class 'str'&gt;, value = \n\nIn [112]: super_print(container.config.attach_stdin)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [113]: super_print(container.config.attach_stdout)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [114]: super_print(container.config.attach_stderr)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [115]: super_print(container.config.exposed_ports)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [116]: super_print(container.config.tty)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [117]: super_print(container.config.open_stdin)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [118]: super_print(container.config.stdin_once)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [119]: super_print(container.config.env)\ntype = &lt;class 'list'&gt;, value = ['PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin']\n\nIn [120]: super_print(container.config.cmd)\ntype = &lt;class 'list'&gt;, value = ['sleep', 'infinity']\n\nIn [121]: super_print(container.config.healthcheck)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [122]: super_print(container.config.args_escaped)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [123]: super_print(container.config.image)\ntype = &lt;class 'str'&gt;, value = ubuntu\n\nIn [124]: super_print(container.config.volumes)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [125]: super_print(container.config.working_dir)\ntype = &lt;class 'pathlib.PosixPath'&gt;, value = .\n\nIn [126]: super_print(container.config.entrypoint)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [127]: super_print(container.config.network_disabled)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [128]: super_print(container.config.mac_address)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [129]: super_print(container.config.on_build)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [130]: super_print(container.config.labels)\ntype = &lt;class 'dict'&gt;, value = {'org.opencontainers.image.ref.name': 'ubuntu', 'org.opencontainers.image.version': '22.04'}\n\nIn [131]: super_print(container.config.stop_signal)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [132]: super_print(container.config.stop_timeout)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [133]: super_print(container.config.shell)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [134]: super_print(container.network_settings.bridge)\ntype = &lt;class 'str'&gt;, value = \n\nIn [135]: super_print(container.network_settings.sandbox_id)\ntype = &lt;class 'str'&gt;, value = 5add8910f3db13c80a6470013a588eb782e7952fb8edc4630dbc0eef7733a389\n\nIn [136]: super_print(container.network_settings.hairpin_mode)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [137]: super_print(container.network_settings.link_local_ipv6_address)\ntype = &lt;class 'str'&gt;, value = \n\nIn [138]: super_print(container.network_settings.link_local_ipv6_prefix_length)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [139]: super_print(container.network_settings.ports)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [140]: super_print(container.network_settings.sandbox_key)\ntype = &lt;class 'pathlib.PosixPath'&gt;, value = /var/run/docker/netns/5add8910f3db\n\nIn [141]: super_print(container.network_settings.secondary_ip_addresses)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [142]: super_print(container.network_settings.secondary_ipv6_addresses)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [143]: super_print(container.network_settings.endpoint_id)\ntype = &lt;class 'str'&gt;, value = 8f1b0895ca3b5be080264499fee219de794eecc6eb254473ffdbd17371e8140d\n\nIn [144]: super_print(container.network_settings.gateway)\ntype = &lt;class 'str'&gt;, value = 172.17.0.1\n\nIn [145]: super_print(container.network_settings.global_ipv6_address)\ntype = &lt;class 'str'&gt;, value = \n\nIn [146]: super_print(container.network_settings.global_ipv6_prefix_length)\ntype = &lt;class 'int'&gt;, value = 0\n\nIn [147]: super_print(container.network_settings.ip_address)\ntype = &lt;class 'str'&gt;, value = 172.17.0.2\n\nIn [148]: super_print(container.network_settings.ip_prefix_length)\ntype = &lt;class 'int'&gt;, value = 16\n\nIn [149]: super_print(container.network_settings.ipv6_gateway)\ntype = &lt;class 'str'&gt;, value = \n\nIn [150]: super_print(container.network_settings.mac_address)\ntype = &lt;class 'str'&gt;, value = 02:42:ac:11:00:02\n\nIn [151]: super_print(container.network_settings.networks)\ntype = &lt;class 'dict'&gt;, value = {'bridge': NetworkInspectResult(ipam_config=None, links=None, aliases=None, network_id='4706f2646f81123d268feaf2f55080fd3ba185960ff7bef240c4c5e002759db3', endpoint_id='8f1b0895ca3b5be080264499fee219de794eecc6eb254473ffdbd17371e8140d', gateway='172.17.0.1', ip_address='172.17.0.2', ip_prefix_length=16, ipv6_gateway='', global_ipv6_address='', global_ipv6_prefix_length=0, mac_address='02:42:ac:11:00:02', driver_options=None)}\n\n</code></pre>"},{"location":"docker_objects/containers/#methods","title":"Methods","text":""},{"location":"docker_objects/containers/#python_on_whales.Container","title":"Container","text":""},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.attach","title":"attach","text":"<pre><code>attach(detach_keys=None, stdin=True, sig_proxy=True)\n</code></pre> <p>Attach local standard input, output, and error streams to a running container.</p> <p>Alias: <code>docker.attach(...)</code></p> <p>See the <code>docker.container.attach</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.commit","title":"commit","text":"<pre><code>commit(tag=None, author=None, message=None, pause=True)\n</code></pre> <p>Create a new image from the container's changes.</p> <p>Alias: <code>docker.commit(...)</code></p> <p>See the <code>docker.container.commit</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.diff","title":"diff","text":"<pre><code>diff()\n</code></pre> <p>Returns the diff of this container filesystem.</p> <p>See the <code>docker.container.diff</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.execute","title":"execute","text":"<pre><code>execute(command, detach=False, envs={}, env_files=[], interactive=False, privileged=False, tty=False, user=None, workdir=None, stream=False)\n</code></pre> <p>Execute a command in this container</p> <p>See the <code>docker.container.execute</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.exists","title":"exists","text":"<pre><code>exists()\n</code></pre> <p>Returns <code>True</code> if the docker container exists and <code>False</code> if it doesn't exists.</p> <p>If it doesn't exists, it most likely mean that it was removed.</p> <p>See the <code>docker.container.exists</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.export","title":"export","text":"<pre><code>export(output)\n</code></pre> <p>Export this container filesystem.</p> <p>See the <code>docker.container.export</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.kill","title":"kill","text":"<pre><code>kill(signal=None)\n</code></pre> <p>Kill this container</p> <p>See the <code>docker.container.kill</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.logs","title":"logs","text":"<pre><code>logs(details=False, since=None, tail=None, timestamps=False, until=None)\n</code></pre> <p>Returns the logs of the container</p> <p>See the <code>docker.container.logs</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.pause","title":"pause","text":"<pre><code>pause()\n</code></pre> <p>Pause this container.</p> <p>See the <code>docker.container.pause</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.remove","title":"remove","text":"<pre><code>remove(force=False, volumes=False)\n</code></pre> <p>Remove this container.</p> <p>See the <code>docker.container.remove</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.rename","title":"rename","text":"<pre><code>rename(new_name)\n</code></pre> <p>Rename this container</p> <p>See the <code>docker.container.rename</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.restart","title":"restart","text":"<pre><code>restart(time=None)\n</code></pre> <p>Restarts this container.</p> <p>See the <code>docker.container.restart</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.start","title":"start","text":"<pre><code>start(attach=False, stream=False)\n</code></pre> <p>Starts this container.</p> <p>See the <code>docker.container.start</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.stop","title":"stop","text":"<pre><code>stop(time=None)\n</code></pre> <p>Stops this container.</p> <p>See the <code>docker.container.stop</code> command for information about the arguments.</p>"},{"location":"docker_objects/containers/#python_on_whales.components.container.cli_wrapper.Container.unpause","title":"unpause","text":"<pre><code>unpause()\n</code></pre> <p>Unpause the container</p> <p>See the <code>docker.container.unpause</code> command for information about the arguments.</p>"},{"location":"docker_objects/images/","title":"Docker images","text":"<p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_docker_image = docker.image.inspect(\"my-image-name\")\n\n# or\n\nmy_docker_image = docker.pull(\"my-image-name\")\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import docker, Image\n\ndef print_dodo(image: Image):\n    print(docker.run(image, [\"echo\", \"dodo\"]))\n</code></pre>"},{"location":"docker_objects/images/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker image inspect ...</code></p> <p>To get a complete description of those attributes, you  can take a look at the daemon api reference page  and click on \"200 No error\".</p> <p>An example is worth many lines of descriptions.</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: image = docker.pull(\"ubuntu\")\n20.04: Pulling from library/ubuntu\n6a5697faee43: Pull complete\nba13d3bc422b: Pull complete\na254829d9e55: Pull complete\nDigest: sha256:fff16eea1a8ae92867721d90c59a75652ea66d29c05294e6e2f898704bdb8cf1\nStatus: Downloaded newer image for ubuntu:latest\ndocker.io/library/ubuntu:latest\n\nIn [3]: def super_print(obj):\n   ...:     print(f\"type={type(obj)}, value={obj}\")\n   ...:\n\nIn [4]: super_print(image.id)\ntype = &lt;class 'str'&gt;, value = sha256:1f6ddc1b2547b2e38dc25b265ac585238a3c23da63976722864dab2a069c74f4\n\nIn [5]: super_print(image.repo_tags)\ntype = &lt;class 'list'&gt;, value = ['ubuntu:latest']\n\nIn [6]: super_print(image.repo_digests)\ntype = &lt;class 'list'&gt;, value = ['ubuntu@sha256:ac58ff7fe25edc58bdf0067ca99df00014dbd032e2246d30a722fa348fd799a5']\n\nIn [7]: super_print(image.parent)\ntype = &lt;class 'str'&gt;, value = \n\nIn [8]: super_print(image.comment)\ntype = &lt;class 'str'&gt;, value = \n\nIn [9]: super_print(image.created)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-05-22 17:45:52.771762+00:00\n\nIn [10]: super_print(image.container)\ntype = &lt;class 'str'&gt;, value = 8e179598db505cae58bc2fed275d23f9dcfb90fc892b8a3e32afedfcd302efda\n\nIn [11]: super_print(image.container_config)\ntype = &lt;class 'python_on_whales.components.container.models.ContainerConfig'&gt;, value = hostname='8e179598db50' domainname='' user='' attach_stdin=False attach_stdout=False attach_stderr=False exposed_ports=None tty=False open_stdin=False stdin_once=False env=['PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'] cmd=['/bin/sh', '-c', '#(nop) ', 'CMD [\"/bin/bash\"]'] healthcheck=None args_escaped=None image='sha256:c155fa819ac4a7589cfb820dbdcc3c7e0d11ceefaade553b744f1970a465ff21' volumes=None working_dir=PosixPath('.') entrypoint=None network_disabled=None mac_address=None on_build=None labels={'org.opencontainers.image.ref.name': 'ubuntu', 'org.opencontainers.image.version': '22.04'} stop_signal=None stop_timeout=None shell=None\n\nIn [12]: super_print(image.docker_version)\ntype = &lt;class 'str'&gt;, value = 20.10.21\n\nIn [13]: super_print(image.author)\ntype = &lt;class 'str'&gt;, value = \n\nIn [14]: super_print(image.config)\ntype = &lt;class 'python_on_whales.components.container.models.ContainerConfig'&gt;, value = hostname='' domainname='' user='' attach_stdin=False attach_stdout=False attach_stderr=False exposed_ports=None tty=False open_stdin=False stdin_once=False env=['PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'] cmd=['/bin/bash'] healthcheck=None args_escaped=None image='sha256:c155fa819ac4a7589cfb820dbdcc3c7e0d11ceefaade553b744f1970a465ff21' volumes=None working_dir=PosixPath('.') entrypoint=None network_disabled=None mac_address=None on_build=None labels={'org.opencontainers.image.ref.name': 'ubuntu', 'org.opencontainers.image.version': '22.04'} stop_signal=None stop_timeout=None shell=None\n\nIn [15]: super_print(image.architecture)\ntype = &lt;class 'str'&gt;, value = amd64\n\nIn [16]: super_print(image.os)\ntype = &lt;class 'str'&gt;, value = linux\n\nIn [17]: super_print(image.os_version)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [18]: super_print(image.size)\ntype = &lt;class 'int'&gt;, value = 77807653\n\nIn [19]: super_print(image.virtual_size)\ntype = &lt;class 'int'&gt;, value = 77807653\n\nIn [20]: super_print(image.graph_driver.name)\ntype = &lt;class 'str'&gt;, value = overlay2\n\nIn [21]: super_print(image.graph_driver.data)\ntype = &lt;class 'dict'&gt;, value = {'MergedDir': '/var/lib/docker/overlay2/c1fad715706fbfc8dc2086a0e8a20c28c22eb8f82a07710e78990c035dc02cab/merged', 'UpperDir': '/var/lib/docker/overlay2/c1fad715706fbfc8dc2086a0e8a20c28c22eb8f82a07710e78990c035dc02cab/diff', 'WorkDir': '/var/lib/docker/overlay2/c1fad715706fbfc8dc2086a0e8a20c28c22eb8f82a07710e78990c035dc02cab/work'}\n\nIn [22]: super_print(image.root_fs.type)\ntype = &lt;class 'str'&gt;, value = layers\n\nIn [23]: super_print(image.root_fs.layers)\ntype = &lt;class 'list'&gt;, value = ['sha256:966e94ab6e166fb358a208cfd8169d22dea352501c96700eb7f45092a2962ee6']\n\nIn [24]: super_print(image.root_fs.base_layer)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [25]: super_print(image.metadata)\ntype = &lt;class 'dict'&gt;, value = {'LastTagTime': '0001-01-01T00:00:00Z'}\n\n</code></pre>"},{"location":"docker_objects/images/#methods","title":"Methods","text":""},{"location":"docker_objects/images/#python_on_whales.Image","title":"Image","text":""},{"location":"docker_objects/images/#python_on_whales.components.image.cli_wrapper.Image.copy_from","title":"copy_from","text":"<pre><code>copy_from(path_in_image, destination, pull='missing')\n</code></pre> <p>Copy a file from a docker image in the local filesystem.</p> <p>See the <code>docker.image.copy_from</code> command for information about the arguments.</p>"},{"location":"docker_objects/images/#python_on_whales.components.image.cli_wrapper.Image.copy_to","title":"copy_to","text":"<pre><code>copy_to(local_path, path_in_image, new_tag=None, pull='missing')\n</code></pre> <p>Copy a file from the local filesystem in a docker image to create a new docker image.</p> <p>As if you did a dockerfile with a COPY instruction.</p> <p>See the <code>docker.image.copy_to</code> command for information about the arguments.</p>"},{"location":"docker_objects/images/#python_on_whales.components.image.cli_wrapper.Image.exists","title":"exists","text":"<pre><code>exists()\n</code></pre> <p>Returns <code>True</code> if the docker image exists and <code>False</code> if it doesn't exists.</p> <p>Note that you might have done <code>docker.image.remove(\"some_tag\")</code> and the image might still exists because python-on-whales references images by id, not by tag.</p> <p>See the <code>docker.image.exists</code> command for information about the arguments.</p>"},{"location":"docker_objects/images/#python_on_whales.components.image.cli_wrapper.Image.remove","title":"remove","text":"<pre><code>remove(force=False, prune=True)\n</code></pre> <p>Remove this Docker image.</p> <p>See the <code>docker.image.remove</code> command for information about the arguments.</p>"},{"location":"docker_objects/images/#python_on_whales.components.image.cli_wrapper.Image.save","title":"save","text":"<pre><code>save(output=None)\n</code></pre> <p>Saves this Docker image in a tar.</p> <p>See the <code>docker.image.save</code> command for information about the arguments.</p>"},{"location":"docker_objects/images/#python_on_whales.components.image.cli_wrapper.Image.tag","title":"tag","text":"<pre><code>tag(new_tag)\n</code></pre> <p>Add a tag to a Docker image.</p> <p>See the <code>docker.image.tag</code> command for information about the arguments.</p>"},{"location":"docker_objects/networks/","title":"Docker networks","text":"<p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_network = docker.network.create(\"some-network\")\n\nmy_network = docker.container.inspect(\"some-network\")\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import Network, docker\n\ndef ping_hostname_in_network(my_network: Network):\n    docker.run(\"busybox\", [\"ping\", \"-c\", \"10\", \"my_hostname\"], networks=[my_network])\n</code></pre>"},{"location":"docker_objects/networks/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker network inspect ...</code></p> <p>If you want to know the exact structure, you can go to the  <code>docker network inspect</code> reference page and click on \"200 no error\". An example is worth many lines of descriptions.</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: network = docker.network.create(\"my-network\")\n\nIn [3]: container = docker.run(\n            \"ubuntu\", [\"sleep\", \"infinity\"], name=\"my_ubuntu\", detach=True, networks=[network]\n        )\n\nIn [4]: def super_print(obj):\n   ...:     print(f\"type={type(obj)}, value={obj}\")\n   ...:\n\nIn [5]: super_print(network.name)\ntype = &lt;class 'str'&gt;, value = my-network\n\nIn [6]: super_print(network.id)\ntype = &lt;class 'str'&gt;, value = af7f0f457540b879c7326526cffb38e94f6b86437cffb13439d170b12564d5dd\n\nIn [7]: super_print(network.created)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:48:57.287270+00:00\n\nIn [8]: super_print(network.scope)\ntype = &lt;class 'str'&gt;, value = local\n\nIn [9]: super_print(network.driver)\ntype = &lt;class 'str'&gt;, value = bridge\n\nIn [10]: super_print(network.enable_ipv6)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [11]: super_print(network.ipam.driver)\ntype = &lt;class 'str'&gt;, value = default\n\nIn [12]: super_print(network.ipam.config)\ntype = &lt;class 'list'&gt;, value = [{'Subnet': '172.19.0.0/16', 'Gateway': '172.19.0.1'}]\n\nIn [13]: super_print(network.ipam.options)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [14]: super_print(network.internal)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [15]: super_print(network.attachable)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [16]: super_print(network.ingress)\ntype = &lt;class 'bool'&gt;, value = False\n\nIn [17]: super_print(network.containers)\ntype = &lt;class 'dict'&gt;, value = {'dcb6b21e145e56443339f9327086c9310e510955910a927f9d1068bb662eefc2': NetworkContainer(name='my_ubuntu', endpoint_id='a4f1eca72aa6672ec0cd1e625cbf5b586752bb9a6e0754245bf64f1dd6e33577', mac_address='02:42:ac:13:00:02', ipv4_address='172.19.0.2/16', ipv6_address='')}\n\nIn [18]: super_print(network.options)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [19]: super_print(network.labels)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [20]: super_print(network.config_from)\ntype = &lt;class 'dict'&gt;, value = {'Network': ''}\n\nIn [21]: super_print(network.config_only)\ntype = &lt;class 'bool'&gt;, value = False\n\n</code></pre>"},{"location":"docker_objects/networks/#methods","title":"Methods","text":""},{"location":"docker_objects/networks/#python_on_whales.Network","title":"Network","text":""},{"location":"docker_objects/networks/#python_on_whales.components.network.cli_wrapper.Network.remove","title":"remove","text":"<pre><code>remove()\n</code></pre> <p>Removes this Docker network.</p> <p>Rather than removing it manually, you can use a context manager to make sure the network is deleted even if an exception is raised.</p> <pre><code>from python_on_whales import docker\n\nwith docker.network.create(\"some_name\") as my_net:\n    docker.run(\n        \"busybox\",\n        [\"ping\", \"idonotexistatall.com\"],\n        networks=[my_net],\n        remove=True,\n    )\n    # an exception will be raised because the container will fail\n    # but the network will be removed anyway.\n</code></pre>"},{"location":"docker_objects/nodes/","title":"Docker nodes","text":"<p>Nodes in Docker swarm</p> <p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_docker_image = docker.node.inspect(\"my-node-name\")\n\nlist_of_nodes = docker.node.list()\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import Node\n\ndef print_state(node: Node):\n    print(node.status.state)\n</code></pre>"},{"location":"docker_objects/nodes/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker node inspect ...</code></p> <p>To get a complete description of those attributes, you  can take a look at the daemon api reference page  and click on \"200 No error\".</p> <p>An example is worth many lines of descriptions.</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: docker.swarm.init()\n\nIn [3]: docker.node.list()[0]\n\nIn [4]: def super_print(obj):\n   ...:     print(f\"type = {type(obj)}, value = {obj}\")\n   ...:\n\nIn [4]: super_print(node.id)\ntype = &lt;class 'str'&gt;, value = vzcq92u1x3ybz2h4aza0xcyv3\n\nIn [5]: super_print(node.version.index)\ntype = &lt;class 'int'&gt;, value = 9\n\nIn [6]: super_print(node.created_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:49:22.000563+00:00\n\nIn [7]: super_print(node.updated_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:49:22.106213+00:00\n\nIn [8]: super_print(node.spec.name)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [9]: super_print(node.spec.labels)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [10]: super_print(node.spec.role)\ntype = &lt;class 'str'&gt;, value = manager\n\nIn [11]: super_print(node.spec.availability)\ntype = &lt;class 'str'&gt;, value = active\n\nIn [12]: super_print(node.description.hostname)\ntype = &lt;class 'str'&gt;, value = fv-az735-458\n\nIn [13]: super_print(node.description.platform.architecture)\ntype = &lt;class 'str'&gt;, value = x86_64\n\nIn [14]: super_print(node.description.platform.os)\ntype = &lt;class 'str'&gt;, value = linux\n\nIn [15]: super_print(node.description.resources.nano_cpus)\ntype = &lt;class 'int'&gt;, value = 2000000000\n\nIn [16]: super_print(node.description.resources.memory_bytes)\ntype = &lt;class 'int'&gt;, value = 7281262592\n\nIn [17]: super_print(node.description.resources.generic_resources)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [18]: super_print(node.description.engine.engine_version)\ntype = &lt;class 'str'&gt;, value = 20.10.24+azure-1\n\nIn [19]: super_print(node.description.engine.labels)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [20]: super_print(node.description.engine.plugins)\ntype = &lt;class 'list'&gt;, value = [EnginePlugin(type='Log', name='awslogs'), EnginePlugin(type='Log', name='fluentd'), EnginePlugin(type='Log', name='gcplogs'), EnginePlugin(type='Log', name='gelf'), EnginePlugin(type='Log', name='journald'), EnginePlugin(type='Log', name='json-file'), EnginePlugin(type='Log', name='local'), EnginePlugin(type='Log', name='logentries'), EnginePlugin(type='Log', name='splunk'), EnginePlugin(type='Log', name='syslog'), EnginePlugin(type='Network', name='bridge'), EnginePlugin(type='Network', name='host'), EnginePlugin(type='Network', name='ipvlan'), EnginePlugin(type='Network', name='macvlan'), EnginePlugin(type='Network', name='null'), EnginePlugin(type='Network', name='overlay'), EnginePlugin(type='Volume', name='local'), EnginePlugin(type='Volume', name='mochoa/s3fs-volume-plugin:latest')]\n\nIn [21]: super_print(node.description.tls_info.trust_root)\ntype = &lt;class 'str'&gt;, value = -----BEGIN CERTIFICATE-----\nMIIBajCCARCgAwIBAgIUFMXKTX72lr+MtbHfay5VFQEUM1EwCgYIKoZIzj0EAwIw\nEzERMA8GA1UEAxMIc3dhcm0tY2EwHhcNMjMwNjA5MTc0NDAwWhcNNDMwNjA0MTc0\nNDAwWjATMREwDwYDVQQDEwhzd2FybS1jYTBZMBMGByqGSM49AgEGCCqGSM49AwEH\nA0IABOuuXyk+lIrxAz1szp0+WEVvo1xBeV0EMmDmTULrmkmJHofQq9X0YbVUGt57\nIhW9NI+Hu4PcVPglRCBUoma3DyajQjBAMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMB\nAf8EBTADAQH/MB0GA1UdDgQWBBTszphyjCOxMPNWRJ7FjcG6gD6YsjAKBggqhkjO\nPQQDAgNIADBFAiEAiwixZ+beoNLFGYcuy6WdAzcT+HQ2leDEc2XwyAiGcL0CIDRd\naVssL+jN4a/QIenyyHPqzztRqPs6dKrC+y+kjZN9\n-----END CERTIFICATE-----\n\n\nIn [22]: super_print(node.description.tls_info.cert_issuer_subject)\ntype = &lt;class 'str'&gt;, value = MBMxETAPBgNVBAMTCHN3YXJtLWNh\n\nIn [23]: super_print(node.description.tls_info.cert_issuer_public_key)\ntype = &lt;class 'str'&gt;, value = MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE665fKT6UivEDPWzOnT5YRW+jXEF5XQQyYOZNQuuaSYkeh9Cr1fRhtVQa3nsiFb00j4e7g9xU+CVEIFSiZrcPJg==\n\nIn [24]: super_print(node.status.state)\ntype = &lt;class 'str'&gt;, value = ready\n\nIn [25]: super_print(node.status.message)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [26]: super_print(node.status.addr)\ntype = &lt;class 'str'&gt;, value = 10.1.0.222\n\nIn [27]: super_print(node.manager_status.leader)\ntype = &lt;class 'bool'&gt;, value = True\n\nIn [28]: super_print(node.manager_status.reachability)\ntype = &lt;class 'str'&gt;, value = reachable\n\nIn [29]: super_print(node.manager_status.addr)\ntype = &lt;class 'str'&gt;, value = 10.1.0.222:2377\n\n</code></pre>"},{"location":"docker_objects/nodes/#methods","title":"Methods","text":""},{"location":"docker_objects/nodes/#python_on_whales.Node","title":"Node","text":""},{"location":"docker_objects/nodes/#python_on_whales.components.node.cli_wrapper.Node.ps","title":"ps","text":"<pre><code>ps()\n</code></pre> <p>Returns the list of tasks running on this node</p>"},{"location":"docker_objects/nodes/#python_on_whales.components.node.cli_wrapper.Node.ps--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Task]` object.\n</code></pre>"},{"location":"docker_objects/nodes/#python_on_whales.components.node.cli_wrapper.Node.update","title":"update","text":"<pre><code>update(availability=None, labels_add={}, rm_labels=[], role=None)\n</code></pre> <p>Updates this Swarm node.</p> <p>See <code>docker.node.update</code> for more information about the arguments.</p>"},{"location":"docker_objects/plugins/","title":"Docker plugins","text":"<p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_docker_plugin = docker.plugin.install(\"vieux/sshfs:latest\")\n# or\nmy_docker_plugin = docker.plugin.inspect(\"vieux/sshfs:latest\")\n# or\nlist_of_plugins = docker.plugins.list()\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import Plugin\n\ndef print_name(plugin: Plugin):\n    print(plugin.name)\n</code></pre>"},{"location":"docker_objects/plugins/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker plugin inspect ...</code></p> <p>To get a complete description of those attributes, you  can take a look at the daemon api reference page  and click on \"200 No error\".</p> <p>An example is worth many lines of descriptions.</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: plugin = docker.plugin.install(\"vieux/sshfs:latest\")\n\nIn [4]: def super_print(obj):\n   ...:     print(f\"type = {type(obj)}, value = {obj}\")\n   ...:\n\nIn [4]: super_print(plugin.id)\ntype = &lt;class 'str'&gt;, value = ac370905eeac9a2d10f053b6fb27c07736c6920ded9aa9a6b32c03418c35dffd\n\nIn [5]: super_print(plugin.name)\ntype = &lt;class 'str'&gt;, value = mochoa/s3fs-volume-plugin:latest\n\nIn [6]: super_print(plugin.enabled)\ntype = &lt;class 'bool'&gt;, value = True\n\nIn [7]: super_print(plugin.settings)\ntype = &lt;class 'python_on_whales.components.plugin.models.PluginSettings'&gt;, value = mounts=[] env=['AWSACCESSKEYID=', 'AWSSECRETACCESSKEY=', 'DEFAULT_S3FSOPTS=nomultipart,use_path_request_style'] args=[] devices=[PluginDevice()]\n\nIn [8]: super_print(plugin.plugin_reference)\ntype = &lt;class 'str'&gt;, value = docker.io/mochoa/s3fs-volume-plugin:latest\n\nIn [9]: super_print(plugin.config)\ntype = &lt;class 'python_on_whales.components.plugin.models.PluginConfig'&gt;, value = docker_version='19.03.15' description='S3FS plugin for Docker v2.0.9' documentation='https://github.com/marcelo-ochoa/docker-volume-plugins/' interface=Interface() entrypoint=['/usr/bin/tini', '--', '/s3fs-volume-plugin'] work_dir=''\n\n</code></pre>"},{"location":"docker_objects/plugins/#methods","title":"Methods","text":""},{"location":"docker_objects/plugins/#python_on_whales.Plugin","title":"Plugin","text":""},{"location":"docker_objects/plugins/#python_on_whales.components.plugin.cli_wrapper.Plugin.disable","title":"disable","text":"<pre><code>disable(force=False)\n</code></pre> <p>Disable this plugin</p>"},{"location":"docker_objects/plugins/#python_on_whales.components.plugin.cli_wrapper.Plugin.enable","title":"enable","text":"<pre><code>enable(timeout=None)\n</code></pre> <p>Enable this plugin</p>"},{"location":"docker_objects/plugins/#python_on_whales.components.plugin.cli_wrapper.Plugin.push","title":"push","text":"<pre><code>push(disable_content_trust=True)\n</code></pre> <p>Push this plugin</p>"},{"location":"docker_objects/plugins/#python_on_whales.components.plugin.cli_wrapper.Plugin.remove","title":"remove","text":"<pre><code>remove(force=False)\n</code></pre> <p>Remove this plugin</p>"},{"location":"docker_objects/plugins/#python_on_whales.components.plugin.cli_wrapper.Plugin.set","title":"set","text":"<pre><code>set(configuration)\n</code></pre> <p>Set the configuration for this plugin</p>"},{"location":"docker_objects/plugins/#python_on_whales.components.plugin.cli_wrapper.Plugin.upgrade","title":"upgrade","text":"<pre><code>upgrade(remote=None, disable_content_trust=True, skip_remote_check=False)\n</code></pre> <p>Upgrade this plugin</p>"},{"location":"docker_objects/secrets/","title":"Secrets","text":""},{"location":"docker_objects/secrets/#python_on_whales.Secret","title":"Secret","text":""},{"location":"docker_objects/secrets/#python_on_whales.components.secret.cli_wrapper.Secret.remove","title":"remove","text":"<pre><code>remove()\n</code></pre> <p>Remove this Docker secret.</p> <p>See the <code>docker.secret.remove</code> command for information about the arguments.</p>"},{"location":"docker_objects/services/","title":"Docker services","text":"<p>Services in Docker swarm</p> <p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_docker_service = docker.service.inspect(\"my-service\")\n\nmy_docker_service = docker.service.create(\"busybox\", [\"ping\", \"www.google.com\"])\n\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import Service\n\ndef print_creation_time(some_service: Service):\n    print(some_service.created_at)\n</code></pre>"},{"location":"docker_objects/services/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker service inspect ...</code></p> <p>To get a complete description of those attributes, you  can take a look at the daemon api reference page  and click on \"200 No error\".</p> <p>An example is worth many lines of descriptions.</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: docker.swarm.init()\n\nIn [3]: my_service = docker.service.create(\"busybox\", [\"ping\", \"www.google.com\"])\n\nIn [4]: def super_print(obj):\n   ...:     print(f\"type = {type(obj)}, value = {obj}\")\n   ...:\n\nIn [4]: super_print(service.id)\ntype = &lt;class 'str'&gt;, value = deouoherku34ywx6t95iusdgo\n\nIn [5]: super_print(service.version)\ntype = &lt;class 'python_on_whales.components.service.models.ServiceVersion'&gt;, value = index=11\n\nIn [6]: super_print(service.created_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:49:23.824288+00:00\n\nIn [7]: super_print(service.updated_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:49:23.824288+00:00\n\nIn [8]: super_print(service.spec.name)\ntype = &lt;class 'str'&gt;, value = sad_driscoll\n\nIn [9]: super_print(service.spec.labels)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [10]: super_print(service.spec.mode)\ntype = &lt;class 'dict'&gt;, value = {'Replicated': {'Replicas': 1}}\n\nIn [11]: super_print(service.spec.update_config)\ntype = &lt;class 'python_on_whales.components.service.models.ChangeConfig'&gt;, value = parallelism=1 failure_action='pause' monitor=5000000000 max_failure_ratio=0 order='stop-first'\n\nIn [12]: super_print(service.spec.rollback_config)\ntype = &lt;class 'python_on_whales.components.service.models.ChangeConfig'&gt;, value = parallelism=1 failure_action='pause' monitor=5000000000 max_failure_ratio=0 order='stop-first'\n\nIn [13]: super_print(service.spec.task_template.container_spec.image)\ntype = &lt;class 'str'&gt;, value = busybox:latest@sha256:560af6915bfc8d7630e50e212e08242d37b63bd5c1ccf9bd4acccf116e262d5b\n\nIn [14]: super_print(service.spec.task_template.container_spec.labels)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [15]: super_print(service.spec.task_template.container_spec.privileges)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [16]: super_print(service.spec.task_template.container_spec.stop_grace_period)\ntype = &lt;class 'int'&gt;, value = 10000000000\n\nIn [17]: super_print(service.spec.task_template.container_spec.isolation)\ntype = &lt;class 'str'&gt;, value = default\n\nIn [18]: super_print(service.spec.task_template.container_spec.env)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [19]: super_print(service.spec.task_template.resources.limits)\ntype = &lt;class 'python_on_whales.components.service.models.CPUMemoryQuotas'&gt;, value = nano_cpus=None memory_bytes=None\n\nIn [20]: super_print(service.spec.task_template.resources.reservations)\ntype = &lt;class 'python_on_whales.components.service.models.CPUMemoryQuotas'&gt;, value = nano_cpus=None memory_bytes=None\n\nIn [21]: super_print(service.previous_spec)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [22]: super_print(service.endpoint.spec)\ntype = &lt;class 'python_on_whales.components.service.models.ServiceEndpointSpec'&gt;, value = mode=None ports=None\n\nIn [23]: super_print(service.endpoint.ports)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [24]: super_print(service.endpoint.virtual_ips)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [25]: super_print(service.update_status)\ntype = &lt;class 'NoneType'&gt;, value = None\n\n</code></pre>"},{"location":"docker_objects/services/#methods","title":"Methods","text":""},{"location":"docker_objects/services/#python_on_whales.Service","title":"Service","text":""},{"location":"docker_objects/services/#python_on_whales.components.service.cli_wrapper.Service.exists","title":"exists","text":"<pre><code>exists()\n</code></pre> <p>Returns <code>True</code> if the service is still present in the swarm, <code>False</code> if the service has been removed.</p>"},{"location":"docker_objects/services/#python_on_whales.components.service.cli_wrapper.Service.ps","title":"ps","text":"<pre><code>ps()\n</code></pre> <p>Returns the list of tasks of this service.</p>"},{"location":"docker_objects/services/#python_on_whales.components.service.cli_wrapper.Service.remove","title":"remove","text":"<pre><code>remove()\n</code></pre> <p>Removes this service</p> <p>It's also possible to use a service as a context manager. By using a context manager, you ensures that the service will be removed even if an exception occurs.</p> <pre><code>from python_on_whales import docker\n\ndocker.swarm.init()\nwith docker.service.create(\"ubuntu\", [\"sleep\", \"infinity\"]) as my_service:\n    print(\"I'm doing things with the service here\")\n    print(my_service.update_status)\n\nprint(\"I'm out of the context manager, the service has been removed.\")\n</code></pre>"},{"location":"docker_objects/services/#python_on_whales.components.service.cli_wrapper.Service.scale","title":"scale","text":"<pre><code>scale(new_scale, detach=False)\n</code></pre> <p>Change the scale of a service.</p> <p>See the <code>docker.service.scale</code> command for information about the arguments.</p>"},{"location":"docker_objects/services/#python_on_whales.components.service.cli_wrapper.Service.update","title":"update","text":"<pre><code>update(detach=False, force=False, image=None, with_registry_authentication=False)\n</code></pre> <p>Updates a service</p> <p>See the <code>docker.service.update</code> command for information about the arguments.</p>"},{"location":"docker_objects/stacks/","title":"Stacks","text":""},{"location":"docker_objects/stacks/#python_on_whales.Stack","title":"Stack","text":""},{"location":"docker_objects/tasks/","title":"Docker tasks","text":"<p>Tasks in Docker swarm</p> <p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_docker_task = docker.task.inspect(\"some-task-id\")\n\nmy_tasks_list = docker.service.ps(\"my-service\")\n\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import Task\n\ndef print_creation_time(some_task: Task):\n    print(some_task.created_at)\n</code></pre>"},{"location":"docker_objects/tasks/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker inspect &lt;task-id&gt;</code></p> <p>To get a complete description of those attributes, you  can take a look at the daemon api reference page  and click on \"200 No error\".</p>"},{"location":"docker_objects/volumes/","title":"Docker volumes","text":"<p>Don't use the constructor directly. Instead use </p> <pre><code>from python_on_whales import docker\n\nmy_docker_volume = docker.volume.inspect(\"my-volume\")\n\n# or\n\nmy_docker_image = docker.volume.create()\n</code></pre> <p>For type hints, use this</p> <pre><code>from python_on_whales import docker, Volume\n\ndef print_file(my_volume: Volume):\n    print(\n        docker.run(\n            \"ubuntu\", \n            [\"cat\", \"/some_volume/some_file\"],\n            volumes=[(my_volume, \"/some_volume/some_file\")]\n        )\n    )\n</code></pre>"},{"location":"docker_objects/volumes/#attributes","title":"Attributes","text":"<p>It attributes are the same that you get with the command line: <code>docker volume inspect ...</code></p> <p>To get a complete description of those attributes, you  can take a look at  the daemon api reference page  and click on \"200 No error\".</p> <p>An example is worth many lines of descriptions.</p> <pre><code>In [1]: from python_on_whales import docker\n\nIn [2]: volume = docker.volume.create()\n\nIn [3]: def super_print(obj):\n   ...:     print(f\"type={type(obj)}, value={obj}\")\n   ...:\n\nIn [4]: super_print(volume.name)\ntype = &lt;class 'str'&gt;, value = bb3b910895ed48ace66c21e0e93d2aa3dd48df28ec834f3be2af093a13019696\n\nIn [5]: super_print(volume.driver)\ntype = &lt;class 'str'&gt;, value = local\n\nIn [6]: super_print(volume.mountpoint)\ntype = &lt;class 'pathlib.PosixPath'&gt;, value = /var/lib/docker/volumes/bb3b910895ed48ace66c21e0e93d2aa3dd48df28ec834f3be2af093a13019696/_data\n\nIn [7]: super_print(volume.created_at)\ntype = &lt;class 'datetime.datetime'&gt;, value = 2023-06-09 17:49:11+00:00\n\nIn [8]: super_print(volume.status)\ntype = &lt;class 'NoneType'&gt;, value = None\n\nIn [9]: super_print(volume.labels)\ntype = &lt;class 'dict'&gt;, value = {}\n\nIn [10]: super_print(volume.scope)\ntype = &lt;class 'str'&gt;, value = local\n\nIn [11]: super_print(volume.options)\ntype = &lt;class 'dict'&gt;, value = {}\n\n</code></pre>"},{"location":"docker_objects/volumes/#methods","title":"Methods","text":""},{"location":"docker_objects/volumes/#python_on_whales.Volume","title":"Volume","text":""},{"location":"docker_objects/volumes/#python_on_whales.components.volume.cli_wrapper.Volume.clone","title":"clone","text":"<pre><code>clone(new_volume_name=None, driver=None, labels={}, options={})\n</code></pre> <p>Creates a new volume and copy all the data inside.</p> <p>See the <code>docker.volume.clone</code> command for information about the arguments.</p>"},{"location":"docker_objects/volumes/#python_on_whales.components.volume.cli_wrapper.Volume.exists","title":"exists","text":"<pre><code>exists()\n</code></pre> <p>Returns <code>True</code> if the docker volume exists and <code>False</code> if it doesn't exists.</p> <p>If it doesn't exists, it most likely mean that it was removed.</p> <p>See the <code>docker.volume.exists</code> command for information about the arguments.</p>"},{"location":"docker_objects/volumes/#python_on_whales.components.volume.cli_wrapper.Volume.remove","title":"remove","text":"<pre><code>remove()\n</code></pre> <p>Removes this volume</p>"},{"location":"sub-commands/buildx/","title":"docker buildx","text":""},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI","title":"BuildxCLI","text":""},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.bake","title":"bake","text":"<pre><code>bake(targets=[], builder=None, files=[], load=False, cache=True, print=False, progress='auto', pull=False, push=False, set={}, variables={}, stream_logs=False)\n</code></pre> <p>Bake is similar to make, it allows you to build things declared in a file.</p> <p>For example it allows you to build multiple docker image in parallel.</p> <p>The CLI docs is here and it contains a lot more information.</p> <p>Parameters:</p> Name Type Description Default <code>targets</code> <code>Union[str, List[str]]</code> <p>Targets or groups of targets to build.</p> <code>[]</code> <code>builder</code> <code>Optional[ValidBuilder]</code> <p>The builder to use.</p> <code>None</code> <code>files</code> <code>Union[ValidPath, List[ValidPath]]</code> <p>Build definition file(s)</p> <code>[]</code> <code>load</code> <code>bool</code> <p>Shorthand for <code>set=[\"*.output=type=docker\"]</code></p> <code>False</code> <code>cache</code> <code>bool</code> <p>Whether to use the cache or not.</p> <code>True</code> <code>print</code> <code>bool</code> <p>Do nothing, just returns the config.</p> <code>False</code> <code>progress</code> <code>Literal['auto', 'plain', 'tty', False]</code> <p>Set type of progress output (<code>\"auto\"</code>, <code>\"plain\"</code>, <code>\"tty\"</code>, or <code>False</code>). Use plain to keep the container output on screen</p> <code>'auto'</code> <code>pull</code> <code>bool</code> <p>Always try to pull the newer version of the image</p> <code>False</code> <code>push</code> <code>bool</code> <p>Shorthand for <code>set=[\"*.output=type=registry\"]</code></p> <code>False</code> <code>set</code> <code>Dict[str, str]</code> <p>A list of overrides in the form <code>\"targetpattern.key=value\"</code>.</p> <code>{}</code> <code>variables</code> <code>Dict[str, str]</code> <p>A dict containing the values of the variables defined in the hcl file. See https://github.com/docker/buildx#hcl-variables-and-functions</p> <code>{}</code>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.bake--returns","title":"Returns","text":"<pre><code>The configuration used for the bake (files merged + override with\nthe arguments used in the function). It's the loaded json you would\nobtain by running `docker buildx bake --print --load my_target` if\nyour command was `docker buildx bake --load my_target`. Some example here.\n</code></pre> <pre><code>from python_on_whales import docker\n\n# returns the config used and runs the builds\nconfig = docker.buildx.bake([\"my_target1\", \"my_target2\"], load=True)\nassert config == {\n    \"target\": {\n        \"my_target1\": {\n            \"context\": \"./\",\n            \"dockerfile\": \"Dockerfile\",\n            \"tags\": [\"pretty_image1:1.0.0\"],\n            \"target\": \"out1\",\n            \"output\": [\"type=docker\"]\n        },\n        \"my_target2\": {\n            \"context\": \"./\",\n            \"dockerfile\": \"Dockerfile\",\n            \"tags\": [\"pretty_image2:1.0.0\"],\n            \"target\": \"out2\",\n            \"output\": [\"type=docker\"]\n        }\n    }\n}\n\n# returns the config only, doesn't run the builds\nconfig = docker.buildx.bake([\"my_target1\", \"my_target2\"], load=True, print=True)\n</code></pre>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.build","title":"build","text":"<pre><code>build(context_path, add_hosts={}, allow=[], attest=None, build_args={}, builder=None, cache=True, cache_from=None, cache_to=None, file=None, labels={}, load=False, network=None, output={}, platforms=None, progress='auto', provenance=None, pull=False, push=False, sbom=None, secrets=[], ssh=None, tags=[], target=None, stream_logs=False)\n</code></pre> <p>Build a Docker image with builkit as backend.</p> <p>Alias: <code>docker.build(...)</code></p> <p>A <code>python_on_whales.Image</code> is returned, even when using multiple tags. That is because it will produce a single image with multiple tags. If no image is loaded into the Docker daemon (if <code>push=True</code> for ex), then <code>None</code> is returned.</p> <p>Parameters:</p> Name Type Description Default <code>context_path</code> <code>ValidPath</code> <p>The path of the build context.</p> required <code>add_hosts</code> <code>Dict[str, str]</code> <p>Hosts to add. <code>add_hosts={\"my_host1\": \"192.168.32.35\"}</code></p> <code>{}</code> <code>allow</code> <code>List[str]</code> <p>List of extra privileges. Eg <code>allow=[\"network.host\", \"security.insecure\"]</code></p> <code>[]</code> <code>attest</code> <code>Optional[Dict[str, str]]</code> <p>Attestation parameters. Eg <code>attest={\"type\": \"sbom\", \"generator\": \"my_image\"}</code></p> <code>None</code> <code>build_args</code> <code>Dict[str, str]</code> <p>The build arguments. ex <code>build_args={\"PY_VERSION\": \"3.7.8\", \"UBUNTU_VERSION\": \"20.04\"}</code>.</p> <code>{}</code> <code>builder</code> <code>Optional[ValidBuilder]</code> <p>Specify which builder to use.</p> <code>None</code> <code>cache</code> <code>bool</code> <p>Whether or not to use the cache</p> <code>True</code> <code>cache_from</code> <code>Union[str, Dict[str, str], List[Dict[str, str]], None]</code> <p>Works only with the container driver. Loads the cache (if needed) from a registry <code>cache_from=\"user/app:cache\"</code>  or a directory on the client <code>cache_from=\"type=local,src=path/to/dir\"</code>. It's also possible to use a dict or list of dict form for this argument. e.g. <code>cache_from=dict(type=\"local\", src=\"path/to/dir\")</code></p> <code>None</code> <code>cache_to</code> <code>Union[str, Dict[str, str], None]</code> <p>Works only with the container driver. Sends the resulting docker cache either to a registry <code>cache_to=\"user/app:cache\"</code>, or to a local directory <code>cache_to=\"type=local,dest=path/to/dir\"</code>. It's also possible to use a dict form for this argument. e.g. <code>cache_to=dict(type=\"local\", dest=\"path/to/dir\", mode=\"max\")</code></p> <code>None</code> <code>file</code> <code>Optional[ValidPath]</code> <p>The path of the Dockerfile</p> <code>None</code> <code>labels</code> <code>Dict[str, str]</code> <p>Dict of labels to add to the image. <code>labels={\"very-secure\": \"1\", \"needs-gpu\": \"0\"}</code> for example.</p> <code>{}</code> <code>load</code> <code>bool</code> <p>Shortcut for <code>output=dict(type=\"docker\")</code> If <code>True</code>, <code>docker.buildx.build</code> will return a <code>python_on_whales.Image</code>.</p> <code>False</code> <code>network</code> <code>Optional[str]</code> <p>which network to use when building the Docker image</p> <code>None</code> <code>output</code> <code>Dict[str, str]</code> <p>Output destination (format: <code>output={\"type\": \"local\", \"dest\": \"path\"}</code> Possible output types are <code>[\"local\", \"tar\", \"oci\", \"docker\", \"image\", \"registry\"]</code>. See this link for more details about each exporter.</p> <code>{}</code> <code>platforms</code> <code>Optional[List[str]]</code> <p>List of target platforms when building the image. Ex: <code>platforms=[\"linux/amd64\", \"linux/arm64\"]</code></p> <code>None</code> <code>progress</code> <code>Literal['auto', 'plain', 'tty', False]</code> <p>Set type of progress output (auto, plain, tty, or False). Use plain to keep the container output on screen</p> <code>'auto'</code> <code>provenance</code> <code>Union[bool, Dict[str, str], None]</code> <p>Shortand for <code>attest={\"type\": \"provenance\"}</code>. Eg <code>provenance=True</code> or <code>provenance=dict(mode=\"max\")</code>. <code>provenance=False</code> might be needed if you are having the issue Default image output from buildx v0.10 cannot run on Google Cloud Run or AWS Lambda</p> <code>None</code> <code>pull</code> <code>bool</code> <p>Always attempt to pull a newer version of the image</p> <code>False</code> <code>push</code> <code>bool</code> <p>Shorthand for <code>output=dict(type=\"registry\")</code>.</p> <code>False</code> <code>sbom</code> <code>Union[bool, Dict[str, str], None]</code> <p>Shorthand for <code>attest={\"type\": \"sbom\"}</code>. Eg <code>sbom=True</code>.</p> <code>None</code> <code>secrets</code> <code>Union[str, List[str]]</code> <p>One or more secrets passed as string(s). For example <code>secrets=\"id=aws,src=/home/my_user/.aws/credentials\"</code></p> <code>[]</code> <code>ssh</code> <code>Optional[str]</code> <p>SSH agent socket or keys to expose to the build (format is <code>default|&lt;id&gt;[=&lt;socket&gt;|&lt;key&gt;[,&lt;key&gt;]]</code> as a string)</p> <code>None</code> <code>tags</code> <code>Union[str, List[str]]</code> <p>Tag or tags to put on the resulting image.</p> <code>[]</code> <code>target</code> <code>Optional[str]</code> <p>Set the target build stage to build.</p> <code>None</code> <code>stream_logs</code> <code>bool</code> <p>If <code>True</code> this function will return an iterator of strings. You can then read the logs as they arrive.</p> <code>False</code>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.build--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Image` if a Docker image is loaded\nin the daemon after the build (the default behavior when\ncalling `docker.build(...)`). Otherwise, `None`.\n</code></pre>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.create","title":"create","text":"<pre><code>create(context_or_endpoint=None, buildkitd_flags=None, config=None, driver=None, driver_options={}, name=None, use=False)\n</code></pre> <p>Create a new builder instance</p> <p>Parameters:</p> Name Type Description Default <code>context_or_endpoint</code> <code>Optional[str]</code> <code>None</code> <code>buildkitd_flags</code> <code>Optional[str]</code> <p>Flags for buildkitd daemon</p> <code>None</code> <code>config</code> <code>Optional[ValidPath]</code> <p>BuildKit config file</p> <code>None</code> <code>driver</code> <code>Optional[str]</code> <p>Driver to use (available: [kubernetes docker docker-container])</p> <code>None</code> <code>driver_options</code> <code>Dict[str, str]</code> <p>Options for the driver. e.g <code>driver_options=dict(network=\"host\")</code></p> <code>{}</code> <code>name</code> <code>Optional[str]</code> <p>Builder instance name</p> <code>None</code> <code>use</code> <code>bool</code> <p>Set the current builder instance to this builder</p> <code>False</code>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.create--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Builder` object.\n</code></pre>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.disk_usage","title":"disk_usage","text":"<pre><code>disk_usage()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.inspect","title":"inspect","text":"<pre><code>inspect(x=None)\n</code></pre> <p>Returns a builder instance from the name.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Optional[str]</code> <p>If <code>None</code> (the default), returns the current builder. If a string is provided, the builder that has this name is returned.</p> <code>None</code>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.inspect--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Builder` object.\n</code></pre>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.is_installed","title":"is_installed","text":"<pre><code>is_installed()\n</code></pre> <p>Returns <code>True</code> if docker buildx is installed and working.</p> <p>If it's not installed, head to the installation page and follow the instructions.</p>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.list","title":"list","text":"<pre><code>list()\n</code></pre> <p>Returns the list of <code>python_on_whales.Builder</code> available.</p>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.prune","title":"prune","text":"<pre><code>prune(all=False, filters={})\n</code></pre> <p>Remove build cache on the current builder.</p> <p>Parameters:</p> Name Type Description Default <code>all</code> <code>bool</code> <p>Remove all cache, not just dangling layers</p> <code>False</code> <code>filters</code> <code>Dict[str, str]</code> <p>Filters to use, for example <code>filters=dict(until=\"24h\")</code></p> <code>{}</code>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.remove","title":"remove","text":"<pre><code>remove(builder)\n</code></pre> <p>Remove a builder</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Union[Builder, str]</code> <p>The builder to remove</p> required"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.stop","title":"stop","text":"<pre><code>stop(builder)\n</code></pre> <p>Stop the builder instance</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Optional[ValidBuilder]</code> <p>The builder to stop. If <code>None</code> (the default value), the current builder is stopped.</p> required"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.use","title":"use","text":"<pre><code>use(builder, default=False, global_=False)\n</code></pre> <p>Set the current builder instance</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Union[Builder, str]</code> <p>The builder to use</p> required <code>default</code> <code>bool</code> <p>Set builder as default for the current context</p> <code>False</code> <code>global_</code> <code>bool</code> <p>Builder will be used even when changing contexts</p> <code>False</code>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.cli_wrapper.BuildxCLI.version","title":"version","text":"<pre><code>version()\n</code></pre> <p>Returns the docker buildx version as a string.</p> <pre><code>from python_on_whales import docker\n\nversion = docker.buildx.version()\nprint(version)\n# \"github.com/docker/buildx v0.4.2 fb7b670b764764dc4716df3eba07ffdae4cc47b2\"\n</code></pre>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.imagetools.cli_wrapper.ImagetoolsCLI","title":"ImagetoolsCLI","text":""},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.imagetools.cli_wrapper.ImagetoolsCLI.create","title":"create","text":"<pre><code>create(sources=[], tags=[], append=False, files=[], dry_run=False, builder=None)\n</code></pre> <p>Create a new manifest list based on source manifests. The source manifests can be manifest lists or single platform distribution manifests and must already exist in the registry where the new manifest is created. If only one source is specified, create performs a carbon copy.</p> <p>The CLI docs is here and it contains a lot more information.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>List[str]</code> <p>The sources manifest to create, change</p> <code>[]</code> <code>append</code> <code>bool</code> <p>Append to existing manifest</p> <code>False</code> <code>dry_run</code> <code>bool</code> <p>Show final image instead of pushing</p> <code>False</code> <code>files</code> <code>List[Union[str, Path]]</code> <p>Read source descriptor from file</p> <code>[]</code> <code>builder</code> <code>Optional[str]</code> <p>The builder to use.</p> <code>None</code>"},{"location":"sub-commands/buildx/#python_on_whales.components.buildx.imagetools.cli_wrapper.ImagetoolsCLI.inspect","title":"inspect","text":"<pre><code>inspect(name)\n</code></pre> <p>Returns the manifest of a Docker image in a registry without pulling it</p>"},{"location":"sub-commands/buildx/#notes-about-the-transition-between-the-legacy-builder-and-buildx","title":"Notes about the transition between the legacy builder and buildx","text":"<p>Users are encouraged to use buildx in Python-on-whales through the <code>docker.build()</code> function.</p> <p>Buildx is the next gen Docker builder and a transition is underway to make the <code>docker build</code> shell command use buildx. Python-on-whales has had an opinionated answer on the matter as <code>docker.build()</code> will always use buildx. This is because Python-on-whales was created  during the transition and doesn't have an existing user codebase to support.</p> <p>The legacy builder is still available by calling <code>docker.legacy_build()</code>, but note that</p> <ul> <li>It won't work if you use Docker 22.06 or above </li> <li>It won't work if you used <code>docker.buildx.install()</code> or <code>docker buildx install</code> previously </li> <li>It won't work if you had set the environment variable <code>DOCKER_BUILDKIT</code> to <code>1</code></li> </ul> <p>Some resources on the matter:</p> <ul> <li>Discussion about supporting the legacy builder in Python-on-whales</li> <li>Proposal: make BuildKit the default builder on Linux</li> <li>Deprecated Engine Features: Legacy builder for Linux images</li> </ul>"},{"location":"sub-commands/compose/","title":"docker compose","text":""},{"location":"sub-commands/compose/#some-notes-about-the-compose-functions","title":"Some notes about the compose functions","text":"<p>Behind the scenes,  the Go implementation of Docker compose is called a.k.a. Compose v2, not the Python implementation.</p> <p>You can verify that <code>docker compose</code> is installed by running</p> <pre><code>docker compose --help\n</code></pre> <p>Be careful! it's different from <code>docker-compose --help</code>! Notice the <code>-</code> between 'docker' and 'compose'. Compose v2 has no <code>-</code> in the command.</p> <p>If that doesn't work, then install the cli plugin. it's just a single binary to download.</p> <p>The Go implementation of compose is still experimental, so take the appropriate precautions.</p> <p>If you don't need to set any project-wide options, like the project name or  the compose file path, you can just import <code>docker</code> and start working.</p> <pre><code>from python_on_whales import docker\n\ndocker.compose.build()\ndocker.compose.up()\n...\ndocker.compose.down()\n</code></pre> <p>Otherwise, you have to define your project-wide options only once, when creating the Docker client.</p> <pre><code>from python_on_whales import DockerClient\n\ndocker = DockerClient(compose_files=[\"./my-compose-file.yml\"])\n\ndocker.compose.build()\ndocker.compose.up()\n...\ndocker.compose.down()\n</code></pre> <p>You have multiple compose options available (like profiles, env_files, project name) when creating the Docker client. You can check them out  in the <code>DockerClient</code> documentation.</p>"},{"location":"sub-commands/compose/#about-dockercomposeimages","title":"About <code>docker.compose.images()</code>.","text":"<p>The Docker command line has a <code>docker compose images</code> command. Python-on-whales doesn't have an equivalent because it's trivial to do so with existing functions.</p> <pre><code>images = [docker.image.inspect(container.image) for container in docker.container.ps()]\n</code></pre> <ul> <li><code>docker.container.ps()</code> returns the list of all containers in the compose stack.</li> <li><code>container.image</code> gives you the id of the Docker image of the container as a <code>str</code>.</li> <li><code>docker.image.inspect()</code> gives you a <code>python_on_whales.Image</code> from a <code>str</code>.</li> </ul>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI","title":"ComposeCLI","text":""},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.build","title":"build","text":"<pre><code>build(services=None, build_args={}, cache=True, progress=None, pull=False, quiet=False, ssh=None)\n</code></pre> <p>Build services declared in a yaml compose file.</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Optional[List[str]]</code> <p>The services to build (as list of strings). If <code>None</code> (default), all services are built. An empty list means that nothing will be built.</p> <code>None</code> <code>build_arguments</code> <p>Set build-time variables for services. For example  <code>build_args={\"PY_VERSION\": \"3.7.8\", \"UBUNTU_VERSION\": \"20.04\"}</code>.</p> required <code>cache</code> <code>bool</code> <p>Set to <code>False</code> if you don't want to use the cache to build your images</p> <code>True</code> <code>progress</code> <code>Optional[str]</code> <p>Set type of progress output (auto, tty, plain, quiet) (default \"auto\")</p> <code>None</code> <code>pull</code> <code>bool</code> <p>Set to <code>True</code> to always attempt to pull a newer version of the image (in the <code>FROM</code> statements for example).</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>Don't print anything</p> <code>False</code> <code>ssh</code> <code>Optional[str]</code> <p>Set SSH authentications used when building service images. (use <code>'default'</code> for using your default SSH Agent)</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.config","title":"config","text":"<pre><code>config(return_json=False)\n</code></pre> <p>Returns the configuration of the compose stack for further inspection.</p> <p>For example</p> <pre><code>from python_on_whales import docker\nproject_config = docker.compose.config()\nprint(project_config.services[\"my_first_service\"].image)\n\"redis\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>return_json</code> <code>bool</code> <p>If <code>False</code>, a <code>ComposeConfig</code> object will be returned, and you 'll be able to take advantage of your IDE autocompletion. If you want the full json output, you may use <code>return_json</code>. In this case, you'll get lists and dicts corresponding to the json response, unmodified. It may be useful if you just want to print the config or want to access a field that was not in the <code>ComposeConfig</code> class.</p> <code>False</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.config--returns","title":"Returns","text":"<pre><code>A `ComposeConfig` object if `return_json` is `False`, and a `dict` otherwise.\n</code></pre>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.create","title":"create","text":"<pre><code>create(services=None, build=False, force_recreate=False, no_build=False, no_recreate=False)\n</code></pre> <p>Creates containers for a service.</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str], None]</code> <p>The name of the services for which the containers will be created. The default <code>None</code> means that the containers for all services will be created. A single string means we will create the container for a single service. A list of string means we will create the containers for each service in the list. An empty list means nothing will be created, the function call is then a no-op.</p> <code>None</code> <code>build</code> <code>bool</code> <p>Build images before starting containers.</p> <code>False</code> <code>force_recreate</code> <code>bool</code> <p>Recreate containers even if their configuration and image haven't changed.</p> <code>False</code> <code>no_build</code> <code>bool</code> <p>Don't build an image, even if it's missing.</p> <code>False</code> <code>no_recreate</code> <p>If containers already exist, don't recreate them. Incompatible with <code>force_recreate=True</code>.</p> <code>False</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.down","title":"down","text":"<pre><code>down(remove_orphans=False, remove_images=None, timeout=None, volumes=False, quiet=False)\n</code></pre> <p>Stops and removes the containers</p> <p>Parameters:</p> Name Type Description Default <code>remove_orphans</code> <code>bool</code> <p>Remove containers for services not defined in the Compose file.</p> <code>False</code> <code>remove_images</code> <code>Optional[str]</code> <p>Remove images used by services. <code>\"local\"</code> remove only images that don't have a custom tag. Possible values are <code>\"local\"</code> and <code>\"all\"</code>.</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>Specify a shutdown timeout in seconds (default 10).</p> <code>None</code> <code>volumes</code> <code>bool</code> <p>Remove named volumes declared in the volumes section of the Compose file and anonymous volumes attached to containers.</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>If <code>False</code>, send to stderr and stdout the progress spinners with the messages. If <code>True</code>, do not display anything.</p> <code>False</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.events","title":"events","text":"<pre><code>events()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.execute","title":"execute","text":"<pre><code>execute(service, command, detach=False, envs={}, index=1, tty=True, privileged=False, user=None, workdir=None)\n</code></pre> <p>Execute a command in a running container.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The name of the service.</p> required <code>command</code> <code>List[str]</code> <p>The command to execute.</p> required <code>detach</code> <code>bool</code> <p>If <code>True</code>, detach from the container after the command exits. In this case,  nothing is returned by the function. By default, the execute command returns only when the  command has finished running, and the function will raise an exception <code>DockerException</code> if the command  exits with a non-zero exit code. If <code>False</code>, the command is executed and the stdout is returned.</p> <code>False</code> <code>envs</code> <code>Dict[str, str]</code> <p>A dictionary of environment variables to set in the container.</p> <code>{}</code> <code>index</code> <code>int</code> <p>The index of the container to execute the command in (default 1) if there are multiple containers for this service.</p> <code>1</code> <code>tty</code> <code>bool</code> <p>If <code>True</code>, allocate a pseudo-TTY. Use <code>False</code> to get the output of the command.</p> <code>True</code> <code>privileged</code> <code>bool</code> <p>If <code>True</code>, run the command in privileged mode.</p> <code>False</code> <code>user</code> <code>Optional[str]</code> <p>The username to use inside the container.</p> <code>None</code> <code>workdir</code> <code>Union[str, Path, None]</code> <p>The working directory inside the container.</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.is_installed","title":"is_installed","text":"<pre><code>is_installed()\n</code></pre> <p>Returns <code>True</code> if docker compose (the one written in Go) is installed and working.</p>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.kill","title":"kill","text":"<pre><code>kill(services=None, signal=None)\n</code></pre> <p>Kills the container(s) of a service</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str]]</code> <p>One or more service(s) to kill. The default (<code>None</code>) is to kill all services. A string means the call will kill one single service. A list of service names can be provided to kill multiple services in one function call. An empty list means that no services are going to be killed, the function is then a no-op.</p> <code>None</code> <code>signal</code> <code>Optional[Union[int, str]]</code> <p>the signal to send to the container. Default is <code>\"SIGKILL\"</code></p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.logs","title":"logs","text":"<pre><code>logs(services=[], tail=None, follow=False, no_log_prefix=False, timestamps=False, since=None, until=None, stream=False)\n</code></pre> <p>View output from containers</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str]]</code> <p>One or more service(s) to view</p> <code>[]</code> <code>tail</code> <code>Optional[str]</code> <p>Number of lines to show from the end of the logs for each container. (default \"all\")</p> <code>None</code> <code>follow</code> <code>bool</code> <p>Follow log output WARNING: With this option, <code>docker.compose.logs()</code> will not return at all. Use it exclusively with <code>stream=True</code>. You can loop on the logs but the loop will never end.</p> <code>False</code> <code>no_log_prefix</code> <code>bool</code> <p>Don't print prefix in logs</p> <code>False</code> <code>timestamps</code> <code>bool</code> <p>Show timestamps</p> <code>False</code> <code>since</code> <code>Optional[str]</code> <p>Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</p> <code>None</code> <code>until</code> <code>Optional[str]</code> <p>Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</p> <code>None</code> <code>stream</code> <code>bool</code> <p>Similar to the <code>stream</code> argument of <code>docker.run()</code>. This function will then return and iterator that will yield a tuple <code>(source, content)</code> with <code>source</code> being <code>\"stderr\"</code> or <code>\"stdout\"</code>. <code>content</code> is the content of the line as bytes. Take a look at the user guide to have an example of the output.</p> <code>False</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.logs--returns","title":"Returns","text":"<pre><code>`str` if `stream=False` (the default), `Iterable[Tuple[str, bytes]]`\nif `stream=True`.\n</code></pre>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.ls","title":"ls","text":"<pre><code>ls(all=False, filters={})\n</code></pre> <p>Returns a list of docker compose projects</p> <p>Parameters:</p> Name Type Description Default <code>all_stopped</code> <p>Results include all stopped compose projects.</p> required <code>project_filters</code> <p>Filter results based on conditions provided.</p> required"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.ls--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.ComposeProject]`\n</code></pre>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.pause","title":"pause","text":"<pre><code>pause(services=None)\n</code></pre> <p>Pause one or more services</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str], None]</code> <p><code>None</code> (the default) means pause all containers of all compose services. A string means that the call will pause the container of a specific service. A list of string means the call will pause the containers of all the services specified. So if an empty list is provided, then this function call is a no-op.</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.port","title":"port","text":"<pre><code>port(service, private_port, index=1, protocol='tcp')\n</code></pre> <p>Returns the public port for a port binding.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The name of the service.</p> required <code>private_port</code> <code>Union[str, int]</code> <p>The private port.</p> required <code>index</code> <code>int</code> <p>Index of the container if service has multiple replicas (default 1)</p> <code>1</code> <code>protocol</code> <code>str</code> <p>tcp or udp (default \"tcp\").</p> <code>'tcp'</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.port--returns","title":"Returns","text":"<pre><code>tuple with (host, port). If port is unknown, then host and port are None.\n</code></pre>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.ps","title":"ps","text":"<pre><code>ps(services=None, all=False)\n</code></pre> <p>Returns the containers that were created by the current project.</p>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.ps--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Container]`\n</code></pre>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.pull","title":"pull","text":"<pre><code>pull(services=None, ignore_pull_failures=False, include_deps=False, quiet=False)\n</code></pre> <p>Pull service images</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[List[str], str, None]</code> <p>The list of services to select. Only the images of those services will be pulled. If no services are specified (<code>None</code>) (the default behavior) all images of all services are pulled. If an empty list is provided, then the function call is a no-op.</p> <code>None</code> <code>ignore_pull_failures</code> <code>bool</code> <p>Pull what it can and ignores images with pull failures</p> <code>False</code> <code>include_deps</code> <code>bool</code> <p>Also pull services declared as dependencies</p> <code>False</code> <code>quiet</code> <code>bool</code> <p>By default, the progress bars are printed in stdout and stderr (both). To disable all output, use <code>quiet=True</code></p> <code>False</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.push","title":"push","text":"<pre><code>push(services=None)\n</code></pre> <p>Push service images</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Optional[List[str]]</code> <p>The list of services to select. Only the images of those services will be pushed. If no services are specified (<code>None</code>, the default behavior) all images of all services are pushed. If an empty list is provided, then the function call is a no-op.</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.restart","title":"restart","text":"<pre><code>restart(services=None, timeout=None)\n</code></pre> <p>Restart containers</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str], None]</code> <p>The names of one or more services to restart (str or list of str). If the argument is not specified, <code>services</code> is <code>None</code> and all services are restarted. If <code>services</code> is an empty list, then the function call is a no-op.</p> <code>None</code> <code>timeout</code> <code>Union[int, timedelta, None]</code> <p>The shutdown timeout (<code>int</code> are interpreted as seconds). <code>None</code> means the CLI default value (10s). See the docker stop docs for more details about this argument.</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.rm","title":"rm","text":"<pre><code>rm(services=None, stop=False, volumes=False)\n</code></pre> <p>Removes stopped service containers</p> <p>By default, anonymous volumes attached to containers will not be removed. You can override this with <code>volumes=True</code>.</p> <p>Any data which is not in a volume will be lost.</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str], None]</code> <p>The names of one or more services to remove (str or list of str). If <code>None</code> (the default) then all services are removed. If an empty list is provided, this function call is a no-op.</p> <code>None</code> <code>stop</code> <code>bool</code> <p>Stop the containers, if required, before removing</p> <code>False</code> <code>volumes</code> <code>bool</code> <p>Remove any anonymous volumes attached to containers</p> <code>False</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.run","title":"run","text":"<pre><code>run(service, command=[], detach=False, labels={}, name=None, tty=True, stream=False, dependencies=True, publish=[], remove=False, service_ports=False, use_aliases=False, user=None, workdir=None)\n</code></pre> <p>Run a one-off command on a service.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>str</code> <p>The name of the service.</p> required <code>command</code> <code>List[str]</code> <p>The command to execute.</p> <code>[]</code> <code>detach</code> <code>bool</code> <p>if <code>True</code>, returns immediately with the Container.     If <code>False</code>, returns the command stdout as string.</p> <code>False</code> <code>labels</code> <code>Dict[str, str]</code> <p>Add or override labels</p> <code>{}</code> <code>name</code> <code>Optional[str]</code> <p>Assign a name to the container.</p> <code>None</code> <code>dependencies</code> <code>bool</code> <p>Also start linked services.</p> <code>True</code> <code>publish</code> <code>List[python_on_whales.components.container.cli_wrapper.ValidPortMapping]</code> <p>Publish a container's port(s) to the host.</p> <code>[]</code> <code>service_ports</code> <code>bool</code> <p>Enable service's ports and map them to the host.</p> <code>False</code> <code>remove</code> <code>bool</code> <p>Automatically remove the container when it exits.</p> <code>False</code> <code>use_aliases</code> <code>bool</code> <p>Use the service's network aliases in the connected network(s).</p> <code>False</code> <code>tty</code> <code>bool</code> <p>Allocate a pseudo-TTY. Allow the process to access your terminal to write on it.</p> <code>True</code> <code>stream</code> <code>bool</code> <p>Similar to <code>docker.run(..., stream=True)</code>.</p> <code>False</code> <code>user</code> <code>Optional[str]</code> <p>Username or UID, format: <code>\"&lt;name|uid&gt;[:&lt;group|gid&gt;]\"</code></p> <code>None</code> <code>workdir</code> <code>Union[None, str, Path]</code> <p>Working directory inside the container</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[str, python_on_whales.components.container.cli_wrapper.Container, Iterable[Tuple[str, bytes]]]</code> <p>Optional[str]</p>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.start","title":"start","text":"<pre><code>start(services=None)\n</code></pre> <p>Start the specified services.</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str], None]</code> <p>The names of one or more services to start. If <code>None</code> (the default), it means all services will start. If an empty list is provided, this function call is a no-op.</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.stop","title":"stop","text":"<pre><code>stop(services=None, timeout=None)\n</code></pre> <p>Stop services</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str], None]</code> <p>The names of one or more services to stop (str or list of str). If <code>None</code> (the default), it means all services will stop. If an empty list is provided, this function call is a no-op.</p> <code>None</code> <code>timeout</code> <code>Union[int, timedelta, None]</code> <p>Number of seconds or timedelta (will be converted to seconds). Specify a shutdown timeout. Default is 10s.</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.top","title":"top","text":"<pre><code>top()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.unpause","title":"unpause","text":"<pre><code>unpause(services=None)\n</code></pre> <p>Unpause one or more services</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[str, List[str], None]</code> <p>One or more service to unpause. If <code>None</code> (the default), all services are unpaused. If services is an empty list, the function call does nothing, it's a no-op.</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.up","title":"up","text":"<pre><code>up(services=None, build=False, detach=False, abort_on_container_exit=False, scales={}, attach_dependencies=False, force_recreate=False, recreate=True, no_build=False, remove_orphans=False, color=True, log_prefix=True, start=True, quiet=False, wait=False, pull=None)\n</code></pre> <p>Start the containers.</p> <p>Reading the logs of the containers is not yet implemented.</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[List[str], str, None]</code> <p>The services to start. If <code>None</code> (default), all services are started. If an empty list is provided, the function call does nothing, it's a no-op.</p> <code>None</code> <code>build</code> <code>bool</code> <p>If <code>True</code>, build the docker images before starting the containers even if a docker image with this name already exists. If <code>False</code> (the default), build only the docker images that do not already exist.</p> <code>False</code> <code>detach</code> <code>bool</code> <p>If <code>True</code>, run the containers in the background. If <code>False</code> this function returns only when all containers have stopped. Incompatible with <code>abort_on_container_exit=True</code>.</p> <code>False</code> <code>abort_on_container_exit</code> <code>bool</code> <p>If <code>True</code> stops all containers if any container was stopped. Incompatible with <code>detach=True</code>.</p> <code>False</code> <code>scales</code> <code>Dict[str, int]</code> <p>Scale SERVICE to NUM instances. Overrides the scale setting in the Compose file if present. For example: <code>scales={\"my_service\": 2, \"my_other_service\": 5}</code>.</p> <code>{}</code> <code>attach_dependencies</code> <code>bool</code> <p>Attach to dependent containers.</p> <code>False</code> <code>force_recreate</code> <code>bool</code> <p>Recreate containers even if their configuration and image haven't changed.</p> <code>False</code> <code>recreate</code> <code>bool</code> <p>Recreate the containers if already exist. <code>recreate=False</code> and <code>force_recreate=True</code> are incompatible.</p> <code>True</code> <code>no_build</code> <code>bool</code> <p>Don't build an image, even if it's missing.</p> <code>False</code> <code>remove_orphans</code> <code>bool</code> <p>Remove containers for services not defined in the Compose file.</p> <code>False</code> <code>color</code> <code>bool</code> <p>If <code>False</code>, it will produce monochrome output.</p> <code>True</code> <code>log_prefix</code> <code>bool</code> <p>If <code>False</code>, will not display the prefix in the logs.</p> <code>True</code> <code>start</code> <code>bool</code> <p>Start the service after creating them.</p> <code>True</code> <code>quiet</code> <code>bool</code> <p>By default, some progress bars and logs are sent to stderr and stdout. Set <code>quiet=True</code> to avoid having any output.</p> <code>False</code> <code>wait</code> <code>bool</code> <p>Wait for services to be running|healthy. Implies detached mode.</p> <code>False</code> <code>pull</code> <code>Literal['always', 'missing', 'never', None]</code> <p>Pull image before running (\u201calways\u201d|\u201dmissing\u201d|\u201dnever\u201d).</p> <code>None</code>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.up--returns","title":"Returns","text":"<pre><code>`None` at the moment. The plan is to be able to capture and stream the logs later.\nIt's not yet implemented.\n</code></pre>"},{"location":"sub-commands/compose/#python_on_whales.components.compose.cli_wrapper.ComposeCLI.version","title":"version","text":"<pre><code>version()\n</code></pre> <p>Returns the version of docker compose as a <code>str</code>.</p>"},{"location":"sub-commands/config/","title":"docker config","text":""},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI","title":"ConfigCLI","text":""},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI.create","title":"create","text":"<pre><code>create(name, file, labels={}, template_driver=None)\n</code></pre> <p>Create a config from a file</p> <p>See the docker docs for more information about swarm configs.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The config name.</p> required <code>file</code> <code>Union[str, Path]</code> <p>Tbe file to be used as config.</p> required <code>labels</code> <code>Dict[str, str]</code> <p>The labels to add to the config</p> <code>{}</code> <code>template_driver</code> <code>Optional[str]</code> <p>The template driver</p> <code>None</code>"},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI.create--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Config` object.\n</code></pre>"},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Returns a <code>python_on_whales.Config</code> object based on its name or id.</p>"},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI.inspect--argument","title":"Argument","text":"<pre><code>x: An id or name or a list of ids/names.\n</code></pre>"},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI.inspect--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Config` if a string was passed as argument. A\n`List[python_on_whales.Config]` if a list of strings was passed as argument.\n</code></pre>"},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI.list","title":"list","text":"<pre><code>list(filters={})\n</code></pre> <p>List all config available in the swarm.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Dict[str, str]</code> <p>If you want to filter the results based on a given condition. For example, <code>docker.config.list(filters=dict(label=\"my_label=hello\"))</code>.</p> <code>{}</code>"},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI.list--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Config]`.\n</code></pre>"},{"location":"sub-commands/config/#python_on_whales.components.config.cli_wrapper.ConfigCLI.remove","title":"remove","text":"<pre><code>remove(x)\n</code></pre> <p>Remove one or more configs.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidConfig, List[ValidConfig]]</code> <p>One or a list of configs. Valid values are the id of the config or a <code>python_on_whales.Config</code> object. An empty list means the function call does nothing.</p> required"},{"location":"sub-commands/container/","title":"docker container","text":""},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI","title":"ContainerCLI","text":""},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.attach","title":"attach","text":"<pre><code>attach(container, detach_keys=None, stdin=True, sig_proxy=True)\n</code></pre> <p>Attach local standard input, output, and error streams to a running container</p> <p>Alias: <code>docker.attach(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>ValidContainer</code> <p>The running container to attach to</p> required <code>detach_keys</code> <code>Optional[str]</code> <p>Override the key sequence for detaching a container</p> <code>None</code> <code>stdin</code> <code>bool</code> <p>Attach STDIN</p> <code>True</code> <code>sig_proxy</code> <code>bool</code> <p>Proxy all received signals to the process (default true)</p> <code>True</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.attach--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.commit","title":"commit","text":"<pre><code>commit(container, tag=None, author=None, message=None, pause=True)\n</code></pre> <p>Create a new image from a container's changes</p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>ValidContainer</code> <p>The container to create the image from</p> required <code>tag</code> <code>Optional[str]</code> <p>tag to apply on the image produced</p> <code>None</code> <code>author</code> <code>Optional[str]</code> <p>Author (e.g., \"John Hannibal Smith hannibal@a-team.com\")</p> <code>None</code> <code>message</code> <code>Optional[str]</code> <p>Commit message</p> <code>None</code> <code>pause</code> <code>bool</code> <p>Pause container during commit</p> <code>True</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.copy","title":"copy","text":"<pre><code>copy(source, destination)\n</code></pre> <p>Copy files/folders between a container and the local filesystem</p> <p>Alias: <code>docker.copy(...)</code></p> <pre><code>from python_on_whales import docker\n\ndocker.run(\"ubuntu\", [\"sleep\", \"infinity\"], name=\"dodo\", remove=True, detach=True)\n\ndocker.copy(\"/tmp/my_local_file.txt\", (\"dodo\", \"/path/in/container.txt\"))\ndocker.copy((\"dodo\", \"/path/in/container.txt\"), \"/tmp/my_local_file2.txt\")\n</code></pre> <p>Doesn't yet support sending or receiving iterators of Python bytes.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[ValidPath, ContainerPath]</code> <p>Local path or tuple. When using a tuple, the first element of the tuple is the container, the second element is the path in the container. ex: <code>source=(\"my-container\", \"/usr/bin/something\")</code>.</p> required <code>destination</code> <code>Union[ValidPath, ContainerPath]</code> <p>Local path or tuple. When using a tuple, the first element of the tuple is the container, the second element is the path in the container. ex: <code>source=(\"my-container\", \"/usr/bin/something\")</code>.</p> required"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.create","title":"create","text":"<pre><code>create(image, command=[], *, add_hosts=[], blkio_weight=None, blkio_weight_device=[], cap_add=[], cap_drop=[], cgroup_parent=None, cgroupns=None, cidfile=None, cpu_period=None, cpu_quota=None, cpu_rt_period=None, cpu_rt_runtime=None, cpu_shares=None, cpus=None, cpuset_cpus=None, cpuset_mems=None, detach=False, devices=[], device_cgroup_rules=[], device_read_bps=[], device_read_iops=[], device_write_bps=[], device_write_iops=[], content_trust=False, dns=[], dns_options=[], dns_search=[], domainname=None, entrypoint=None, envs={}, env_files=[], expose=[], gpus=None, groups_add=[], healthcheck=True, health_cmd=None, health_interval=None, health_retries=None, health_start_period=None, health_timeout=None, hostname=None, init=False, ip=None, ip6=None, ipc=None, isolation=None, kernel_memory=None, labels={}, label_files=[], link=[], link_local_ip=[], log_driver=None, log_options=[], mac_address=None, memory=None, memory_reservation=None, memory_swap=None, memory_swappiness=None, mounts=[], name=None, networks=[], network_aliases=[], oom_kill=True, oom_score_adj=None, pid=None, pids_limit=None, platform=None, privileged=False, publish=[], publish_all=False, pull='missing', read_only=False, restart=None, remove=False, runtime=None, security_options=[], shm_size=None, sig_proxy=True, stop_signal=None, stop_timeout=None, storage_options=[], sysctl={}, tmpfs=[], ulimit=[], user=None, userns=None, uts=None, volumes=[], volume_driver=None, volumes_from=[], workdir=None)\n</code></pre> <p>Creates a container, but does not start it.</p> <p>Alias: <code>docker.create(...)</code></p> <p>Start it then with the <code>.start()</code> method.</p> <p>It might be useful if you want to delay the start of a container, to do some preparations beforehand. For example, it's common to do this workflow: <code>docker create</code> -&gt; <code>docker cp</code> -&gt; <code>docker start</code> to put files in the container before starting.</p> <p>There is no <code>detach</code> argument since it's a runtime option.</p> <p>The arguments are the same as <code>docker.run</code>.</p>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.diff","title":"diff","text":"<pre><code>diff(container)\n</code></pre> <p>List all the files modified, added or deleted since the container started.</p> <p>Alias: <code>docker.diff(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>ValidContainer</code> <p>The container to inspect</p> required"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.diff--returns","title":"Returns","text":"<pre><code>`Dict[str, str]` Something like\n`{\"/some_path\": \"A\", \"/some_file\": \"M\", \"/tmp\": \"D\"}` for example.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.execute","title":"execute","text":"<pre><code>execute(container, command, detach=False, envs={}, env_files=[], interactive=False, privileged=False, tty=False, user=None, workdir=None, stream=False)\n</code></pre> <p>Execute a command inside a container</p> <p>Alias: <code>docker.execute(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>ValidContainer</code> <p>The container to execute the command in.</p> required <code>command</code> <code>Union[str, List[str]]</code> <p>The command to execute.</p> required <code>detach</code> <code>bool</code> <p>if <code>True</code>, returns immediately with <code>None</code>. If <code>False</code>, returns the command stdout as string.</p> <code>False</code> <code>envs</code> <code>Dict[str, str]</code> <p>Set environment variables</p> <code>{}</code> <code>env_files</code> <code>Union[ValidPath, List[ValidPath]]</code> <p>Read one or more files of environment variables</p> <code>[]</code> <code>interactive</code> <code>bool</code> <p>Leave stdin open during the duration of the process to allow communication with the parent process. Currently only works with <code>tty=True</code> for interactive use on the terminal.</p> <code>False</code> <code>privileged</code> <code>bool</code> <p>Give extended privileges to the container.</p> <code>False</code> <code>tty</code> <code>bool</code> <p>Allocate a pseudo-TTY. Allow the process to access your terminal to write on it.</p> <code>False</code> <code>user</code> <code>Optional[str]</code> <p>Username or UID, format: <code>\"&lt;name|uid&gt;[:&lt;group|gid&gt;]\"</code></p> <code>None</code> <code>workdir</code> <code>Optional[ValidPath]</code> <p>Working directory inside the container</p> <code>None</code> <code>stream</code> <code>bool</code> <p>Similar to <code>docker.run(..., stream=True)</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[None, str, Iterable[Tuple[str, bytes]]]</code> <p>Optional[str]</p>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.execute--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.exists","title":"exists","text":"<pre><code>exists(x)\n</code></pre> <p>Returns <code>True</code> if the container exists. <code>False</code> otherwise.</p> <p>It's just calling <code>docker.container.inspect(...)</code> and verifies that it doesn't throw  a <code>python_on_whales.exceptions.NoSuchContainer</code>.</p>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.exists--returns","title":"Returns","text":"<pre><code>A `bool`\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.export","title":"export","text":"<pre><code>export(container, output)\n</code></pre> <p>Export a container's filesystem as a tar archive</p> <p>Alias: <code>docker.export(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>ValidContainer</code> <p>The container to export.</p> required <code>output</code> <code>ValidPath</code> <p>The path of the output tar archive. Returning a generator of bytes is not yet implemented.</p> required"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.export--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Returns a container object from a name or ID.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <p>A container name or ID, or a list of container names and/or IDs</p> required <p>Returns:</p> Type Description <code>Union[Container, List[Container]]</code> <p>A <code>python_on_whales.Container</code> object or a list of those</p> <code>Union[Container, List[Container]]</code> <p>if a list of IDs was passed as input.</p>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.inspect--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.kill","title":"kill","text":"<pre><code>kill(containers, signal=None)\n</code></pre> <p>Kill a container.</p> <p>Alias: <code>docker.kill(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>containers</code> <code>Union[ValidContainer, List[ValidContainer]]</code> <p>One or more containers to kill</p> required <code>signal</code> <code>Optional[Union[int, str]]</code> <p>The signal to send the container</p> <code>None</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.kill--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.list","title":"list","text":"<pre><code>list(all=False, filters={})\n</code></pre> <p>List the containers on the host.</p> <p>Alias: <code>docker.ps(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>all</code> <code>bool</code> <p>If <code>True</code>, also returns containers that are not running.</p> <code>False</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.list--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Container]`\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.logs","title":"logs","text":"<pre><code>logs(container, details=False, since=None, tail=None, timestamps=False, until=None, follow=False, stream=False)\n</code></pre> <p>Returns the logs of a container as a string or an iterator.</p> <p>Alias: <code>docker.logs(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>Union[Container, str]</code> <p>The container to get the logs of</p> required <code>details</code> <code>bool</code> <p>Show extra details provided to logs</p> <code>False</code> <code>since</code> <code>Union[None, datetime, timedelta]</code> <p>Use a datetime or timedelta to specify the lower date limit for the logs.</p> <code>None</code> <code>tail</code> <code>Optional[int]</code> <p>Number of lines to show from the end of the logs (default all)</p> <code>None</code> <code>timestamps</code> <code>bool</code> <p>Put timestamps next to lines.</p> <code>False</code> <code>until</code> <code>Union[None, datetime, timedelta]</code> <p>Use a datetime or a timedelta to specify the upper date limit for the logs.</p> <code>None</code> <code>follow</code> <code>bool</code> <p>If <code>False</code> (the default), the logs returned are the logs up to the time of the function call. If <code>True</code>, the logs of the container up to the time the container stopped are displayed. Which means that if the container isn't stopped yet, the function will continue until the container is stopped. Which is why it is advised to use the <code>stream</code> option if you use the <code>follow</code> option. Without <code>stream</code>, only a <code>str</code> will be returned, possibly much later in the future. With <code>stream</code>, you'll be able to read the logs in real time.</p> <code>False</code> <code>stream</code> <code>bool</code> <p>Similar to the <code>stream</code> argument of <code>docker.run</code>. This function will then returns and iterator that will yield a tuple <code>(source, content)</code> with <code>source</code> being <code>\"stderr\"</code> or <code>\"stdout\"</code>. <code>content</code> is the content of the line as bytes. Take a look at the user guide to have an example of the output.</p> <code>False</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.logs--returns","title":"Returns","text":"<pre><code>`str` if `stream=False` (the default), `Iterable[Tuple[str, bytes]]`\nif `stream=True`.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.logs--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre> <p>If you are a bit confused about <code>follow</code> and <code>stream</code>, here are some use cases.</p> <ul> <li>If you want to have the logs up to this point as a <code>str</code>, don't use those args.</li> <li>If you want to stream the output in real time, use <code>follow=True, stream=True</code></li> <li>If you want the logs up to this point but you don't want to fit all the logs in memory because they are too big, use <code>stream=True</code>.</li> </ul>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.pause","title":"pause","text":"<pre><code>pause(containers)\n</code></pre> <p>Pauses one or more containers</p> <p>Alias: <code>docker.pause(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>containers</code> <code>Union[ValidContainer, List[ValidContainer]]</code> <p>One or more containers to pause</p> required"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.pause--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.prune","title":"prune","text":"<pre><code>prune(filters={})\n</code></pre> <p>Remove containers that are not running.</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Dict[str, str]</code> <p>Filters as strings or list of strings</p> <code>{}</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.remove","title":"remove","text":"<pre><code>remove(containers, force=False, volumes=False)\n</code></pre> <p>Removes a container</p> <p>Alias: <code>docker.remove(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>containers</code> <code>Union[Container, str, List[Union[Container, str]]]</code> <p>One or more containers.</p> required <code>force</code> <code>bool</code> <p>Force the removal of a running container (uses SIGKILL)</p> <code>False</code> <code>volumes</code> <code>bool</code> <p>Remove anonymous volumes associated with the container</p> <code>False</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.remove--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.rename","title":"rename","text":"<pre><code>rename(container, new_name)\n</code></pre> <p>Changes the name of a container.</p> <p>Alias: <code>docker.rename(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>container</code> <code>ValidContainer</code> <p>The container to rename</p> required <code>new_name</code> <code>str</code> <p>The new name of the container.</p> required"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.rename--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.restart","title":"restart","text":"<pre><code>restart(containers, time=None)\n</code></pre> <p>Restarts one or more container.</p> <p>Alias: <code>docker.restart(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>containers</code> <code>Union[ValidContainer, List[ValidContainer]]</code> <p>One or more containers to restart</p> required <code>time</code> <code>Optional[Union[int, timedelta]]</code> <p>Amount of to wait for stop before killing the container (default 10s). If <code>int</code>, the unit is seconds.</p> <code>None</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.restart--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.run","title":"run","text":"<pre><code>run(image, command=[], *, add_hosts=[], blkio_weight=None, blkio_weight_device=[], cap_add=[], cap_drop=[], cgroup_parent=None, cgroupns=None, cidfile=None, cpu_period=None, cpu_quota=None, cpu_rt_period=None, cpu_rt_runtime=None, cpu_shares=None, cpus=None, cpuset_cpus=None, cpuset_mems=None, detach=False, devices=[], device_cgroup_rules=[], device_read_bps=[], device_read_iops=[], device_write_bps=[], device_write_iops=[], content_trust=False, dns=[], dns_options=[], dns_search=[], domainname=None, entrypoint=None, envs={}, env_files=[], expose=[], gpus=None, groups_add=[], healthcheck=True, health_cmd=None, health_interval=None, health_retries=None, health_start_period=None, health_timeout=None, hostname=None, init=False, interactive=False, ip=None, ip6=None, ipc=None, isolation=None, kernel_memory=None, labels={}, label_files=[], link=[], link_local_ip=[], log_driver=None, log_options=[], mac_address=None, memory=None, memory_reservation=None, memory_swap=None, memory_swappiness=None, mounts=[], name=None, networks=[], network_aliases=[], oom_kill=True, oom_score_adj=None, pid=None, pids_limit=None, platform=None, privileged=False, publish=[], publish_all=False, pull='missing', read_only=False, restart=None, remove=False, runtime=None, security_options=[], shm_size=None, sig_proxy=True, stop_signal=None, stop_timeout=None, storage_options=[], stream=False, sysctl={}, tmpfs=[], tty=False, ulimit=[], user=None, userns=None, uts=None, volumes=[], volume_driver=None, volumes_from=[], workdir=None)\n</code></pre> <p>Runs a container</p> <p>You can use <code>docker.run</code> or <code>docker.container.run</code> to call this function.</p> <p>For a deeper dive into the arguments and what they do, visit https://docs.docker.com/engine/reference/run/</p> <p>If you want to know exactly how to call <code>docker.run()</code> depending on your use case (detach, stream...), take a look at the <code>docker.run()</code> guide.</p> <pre><code>&gt;&gt;&gt; from python_on_whales import docker\n&gt;&gt;&gt; returned_string = docker.run(\"hello-world\")\n&gt;&gt;&gt; print(returned_string)\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n</code></pre> <pre><code>&gt;&gt;&gt; from python_on_whales import docker\n&gt;&gt;&gt; result_string = docker.run(\"ubuntu\", [\"ls\", \"/host\"], volumes=[(\"/\", \"/host\", \"ro\")])\n&gt;&gt;&gt; print(result_string)\nbin\nboot\ndev\netc\nhome\ninit\nlib\nlib64\nlost+found\nmedia\nmnt\nopt\nproc\nprojects\nroot\nrun\nsbin\nsnap\nsrv\nsys\ntmp\nusr\nvar\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>python_on_whales.components.image.cli_wrapper.ValidImage</code> <p>The docker image to use for the container</p> required <code>command</code> <code>List[str]</code> <p>List of arguments to provide to the container.</p> <code>[]</code> <code>add_hosts</code> <code>List[Tuple[str, str]]</code> <p>hosts to add in the format of a tuple. For example, <code>add_hosts=[(\"my_host_1\", \"192.168.30.31\"), (\"host2\", \"192.168.80.81\")]</code></p> <code>[]</code> <code>blkio_weight</code> <code>Optional[int]</code> <p>Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</p> <code>None</code> <code>cgroupns</code> <code>Optional[str]</code> <p>Cgroup namespace mode to use, one of 'host' or 'private'.</p> <code>None</code> <code>cpu_period</code> <code>Optional[int]</code> <p>Limit CPU CFS (Completely Fair Scheduler) period</p> <code>None</code> <code>cpu_quota</code> <code>Optional[int]</code> <p>Limit CPU CFS (Completely Fair Scheduler) quota</p> <code>None</code> <code>cpu_rt_period</code> <code>Optional[int]</code> <p>Limit CPU real-time period in microseconds</p> <code>None</code> <code>cpu_rt_runtime</code> <code>Optional[int]</code> <p>Limit CPU real-time runtime in microseconds</p> <code>None</code> <code>cpu_shares</code> <code>Optional[int]</code> <p>CPU shares (relative weight)</p> <code>None</code> <code>cpus</code> <code>Optional[float]</code> <p>The maximal amount of cpu the container can use. <code>1</code> means one cpu core.</p> <code>None</code> <code>cpuset_cpus</code> <code>Optional[List[int]]</code> <p>CPUs in which to allow execution. Must be given as a list.</p> <code>None</code> <code>cpuset_mems</code> <code>Optional[List[int]]</code> <p>MEMs in which to allow execution. Must be given as a list.</p> <code>None</code> <code>detach</code> <code>bool</code> <p>If <code>False</code>, returns the ouput of the container as a string. If <code>True</code>, returns a <code>python_on_whales.Container</code> object.</p> <code>False</code> <code>dns_search</code> <code>List[str]</code> <p>Set custom DNS search domains</p> <code>[]</code> <code>domainname</code> <code>Optional[str]</code> <p>Container NIS domain name</p> <code>None</code> <code>entrypoint</code> <code>Optional[str]</code> <p>Overwrite the default ENTRYPOINT of the image</p> <code>None</code> <code>envs</code> <code>Dict[str, str]</code> <p>Environment variables as a <code>dict</code>. For example: <code>{\"OMP_NUM_THREADS\": 3}</code></p> <code>{}</code> <code>env_files</code> <code>Union[ValidPath, List[ValidPath]]</code> <p>One or a list of env files.</p> <code>[]</code> <code>gpus</code> <code>Union[int, str, None]</code> <p>For this to work, you need the Nvidia container runtime The value needed is a <code>str</code> or <code>int</code>. Some examples of valid argument are <code>\"all\"</code> or <code>\"device=GPU-3a23c669-1f69-c64e-cf85-44e9b07e7a2a\"</code> or <code>\"device=0,2\"</code>. If you want 3 gpus, just write <code>gpus=3</code>.</p> <code>None</code> <code>hostname</code> <code>Optional[str]</code> <p>Container host name</p> <code>None</code> <code>interactive</code> <code>bool</code> <p>Leave stdin open during the duration of the process to allow communication with the parent process. Currently only works with <code>tty=True</code> for interactive use on the terminal.</p> <code>False</code> <code>ip</code> <code>Optional[str]</code> <p>IPv4 address (e.g., 172.30.100.104)</p> <code>None</code> <code>ip6</code> <code>Optional[str]</code> <p>IPv6 address (e.g., 2001:db8::33)</p> <code>None</code> <code>ipc</code> <code>Optional[str]</code> <p>IPC mode to use</p> <code>None</code> <code>isolation</code> <code>Optional[str]</code> <p>Container isolation technology</p> <code>None</code> <code>kernel_memory</code> <code>Union[int, str, None]</code> <p>Kernel memory limit. <code>int</code> represents the number of bytes, but you can use <code>\"4k\"</code> or <code>2g</code> for example.</p> <code>None</code> <code>labels</code> <code>Dict[str, str]</code> <p>Set meta data on a container. The labels can be used later when filtering containers with <code>docker.ps(filters='...')</code>. The labels can also be found on each container with the attribute <code>my_container.config.labels</code>.</p> <code>{}</code> <code>log_driver</code> <code>Optional[str]</code> <p>Logging driver for the container</p> <code>None</code> <code>mac_address</code> <code>Optional[str]</code> <p>Container MAC address (e.g., <code>\"92:d0:c6:0a:29:33\"</code>)</p> <code>None</code> <code>memory</code> <code>Union[int, str, None]</code> <p>Memory limit, valid values are <code>1024</code> (ints are bytes) or <code>\"43m\"</code> or <code>\"6g\"</code>.</p> <code>None</code> <code>memory_reservation</code> <code>Union[int, str, None]</code> <p>Memory soft limit</p> <code>None</code> <code>memory_swap</code> <code>Union[int, str, None]</code> <p>Swap limit equal to memory plus swap: '-1' to enable unlimited swap.</p> <code>None</code> <code>memory_swappiness</code> <code>Optional[int]</code> <p>Tune container memory swappiness (0 to 100) (default -1)</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>The container name. If not provided, one is automatically genrated for you.</p> <code>None</code> <code>healthcheck</code> <code>bool</code> <p>Set to <code>False</code> to disable container periodic healthcheck.</p> <code>True</code> <code>oom_kill</code> <code>bool</code> <p>Set to <code>False</code> to disable the OOM killer for this container.</p> <code>True</code> <code>pid</code> <code>Optional[str]</code> <p>PID namespace to use</p> <code>None</code> <code>pids_limit</code> <code>Optional[int]</code> <p>Tune container pids limit (set <code>-1</code> for unlimited)</p> <code>None</code> <code>platform</code> <code>Optional[str]</code> <p>Set platform if server is multi-platform capable.</p> <code>None</code> <code>privileged</code> <code>bool</code> <p>Give extended privileges to this container.</p> <code>False</code> <code>publish</code> <code>List[ValidPortMapping]</code> <p>Ports to publish, same as the <code>-p</code> argument in the Docker CLI. example are <code>[(8000, 7000) , (\"127.0.0.1:3000\", 2000)]</code> or <code>[(\"127.0.0.1:3000\", 2000, \"udp\")]</code>. You can also use a single entry in the tuple to signify that you want a random free port on the host. For example: <code>publish=[(80,)]</code>.</p> <code>[]</code> <code>publish_all</code> <code>bool</code> <p>Publish all exposed ports to random ports.</p> <code>False</code> <code>pull</code> <code>str</code> <p>Pull image before running (\"always\"|\"missing\"|\"never\") (default \"missing\").</p> <code>'missing'</code> <code>read_only</code> <code>bool</code> <p>Mount the container's root filesystem as read only.</p> <code>False</code> <code>restart</code> <code>Optional[str]</code> <p>Restart policy to apply when a container exits (default \"no\")</p> <code>None</code> <code>remove</code> <code>bool</code> <p>Automatically remove the container when it exits.</p> <code>False</code> <code>runtime</code> <code>Optional[str]</code> <p>Runtime to use for this container.</p> <code>None</code> <code>security_options</code> <code>List[str]</code> <p>Security options</p> <code>[]</code> <code>shm_size</code> <code>Union[int, str, None]</code> <p>Size of /dev/shm. <code>int</code> is for bytes. But you can use <code>\"512m\"</code> or <code>\"4g\"</code> for example.</p> <code>None</code> <code>stop_timeout</code> <code>Optional[int]</code> <p>Signal to stop a container (default \"SIGTERM\")</p> <code>None</code> <code>storage_options</code> <code>List[str]</code> <p>Storage driver options for the container</p> <code>[]</code> <code>tty</code> <code>bool</code> <p>Allocate a pseudo-TTY. Allow the process to access your terminal to write on it.</p> <code>False</code> <code>user</code> <code>Optional[str]</code> <p>Username or UID (format: <code>&lt;name|uid&gt;[:&lt;group|gid&gt;]</code>)</p> <code>None</code> <code>userns</code> <code>Optional[str]</code> <p>User namespace to use</p> <code>None</code> <code>uts</code> <code>Optional[str]</code> <p>UTS namespace to use</p> <code>None</code> <code>volumes</code> <code>Optional[List[python_on_whales.components.volume.cli_wrapper.VolumeDefinition]]</code> <p>Bind mount a volume. Some examples: <code>[(\"/\", \"/host\"), (\"/etc/hosts\", \"/etc/hosts\", \"rw\")]</code>.</p> <code>[]</code> <code>volume_driver</code> <code>Optional[str]</code> <p>Optional volume driver for the container</p> <code>None</code> <code>workdir</code> <code>Optional[ValidPath]</code> <p>The directory in the container where the process will be executed.</p> <code>None</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.run--returns","title":"Returns","text":"<pre><code>The container output as a string if detach is `False` (the default),\nand a `python_on_whales.Container` if detach is `True`.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.start","title":"start","text":"<pre><code>start(containers, attach=False, stream=False)\n</code></pre> <p>Starts one or more stopped containers.</p> <p>Aliases: <code>docker.start</code>, <code>docker.container.start</code>, <code>python_on_whales.Container.start</code>.</p> <p>Parameters:</p> Name Type Description Default <code>containers</code> <code>Union[ValidContainer, List[ValidContainer]]</code> <p>One or a list of containers.</p> required"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.stats","title":"stats","text":"<pre><code>stats(containers=None, all=False)\n</code></pre> <p>Get containers resource usage statistics</p> <p>Alias: <code>docker.stats(...)</code></p> <p>Usage:</p> <pre><code>from python_on_whales import docker\n\ndocker.run(\"redis\", detach=True)\nprint(docker.stats())\n# [&lt;&lt;class 'python_on_whales.components.container.ContainerStats'&gt; object,\n# attributes are block_read=0, block_write=0, cpu_percentage=0.08,\n# container=e90ae41a5b17,\n# container_id=e90ae41a5b17df998584141692f1e361c485e8d00c37ee21fdc360d3523dd1c1,\n# memory_percentage=0.18, memory_used=11198791, memory_limit=6233071288,\n# container_name=crazy_northcutt, net_upload=696, net_download=0&gt;]\n</code></pre> <p>The data unit is the byte.</p> <p>Parameters:</p> Name Type Description Default <code>all</code> <code>bool</code> <p>Get the stats of all containers, not just running ones.</p> <code>False</code> <code>containers</code> <code>Optional[Union[ValidContainer, List[ValidContainer]]]</code> <p>One or a list of containers.</p> <code>None</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.stats--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.ContainerStats]`.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.stop","title":"stop","text":"<pre><code>stop(containers, time=None)\n</code></pre> <p>Stops one or more running containers</p> <p>Alias: <code>docker.stop(...)</code></p> <p>Aliases: <code>docker.stop</code>, <code>docker.container.stop</code>, <code>python_on_whales.Container.stop</code>.</p> <p>Parameters:</p> Name Type Description Default <code>containers</code> <code>Union[ValidContainer, List[ValidContainer]]</code> <p>One or a list of containers.</p> required <code>time</code> <code>Union[int, timedelta]</code> <p>Seconds to wait for stop before killing a container (default 10)</p> <code>None</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.stop--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.top","title":"top","text":"<pre><code>top()\n</code></pre> <p>Get the running processes of a container</p> <p>Alias: <code>docker.top(...)</code></p> <p>Not yet implemented</p>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.unpause","title":"unpause","text":"<pre><code>unpause(x)\n</code></pre> <p>Unpause all processes within one or more containers</p> <p>Alias: <code>docker.unpause(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidContainer, List[ValidContainer]]</code> <p>One or more containers (name, id or <code>python_on_whales.Container</code> object).</p> required"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.unpause--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.update","title":"update","text":"<pre><code>update(x, blkio_weight=None, cpu_period=None, cpu_quota=None, cpu_rt_period=None, cpu_rt_runtime=None, cpu_shares=None, cpus=None, cpuset_cpus=None, cpuset_mems=None, kernel_memory=None, memory=None, memory_reservation=None, memory_swap=None, pids_limit=None, restart=None)\n</code></pre> <p>Update configuration of one or more containers</p> <p>Alias: <code>docker.update(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidContainer, List[ValidContainer]]</code> <p>One or a list of containers to update.</p> required <code>blkio_weight</code> <code>Optional[int]</code> <p>Block IO (relative weight), between 10 and 1000, or 0 to disable (default 0)</p> <code>None</code> <code>cpu_period</code> <code>Optional[int]</code> <p>Limit CPU CFS (Completely Fair Scheduler) period</p> <code>None</code> <code>cpu_quota</code> <code>Optional[int]</code> <p>Limit CPU CFS (Completely Fair Scheduler) quota</p> <code>None</code> <code>cpu_rt_period</code> <code>Optional[int]</code> <p>Limit CPU real-time period in microseconds</p> <code>None</code> <code>cpu_rt_runtime</code> <code>Optional[int]</code> <p>Limit CPU real-time runtime in microseconds</p> <code>None</code> <code>cpu_shares</code> <code>Optional[int]</code> <p>CPU shares (relative weight)</p> <code>None</code> <code>cpus</code> <code>Optional[float]</code> <p>The maximal amount of cpu the container can use. <code>1</code> means one cpu core.</p> <code>None</code> <code>cpuset_cpus</code> <code>Optional[List[int]]</code> <p>CPUs in which to allow execution. Must be given as a list.</p> <code>None</code> <code>cpuset_mems</code> <code>Optional[List[int]]</code> <p>MEMs in which to allow execution. Must be given as a list.</p> <code>None</code> <code>memory</code> <code>Union[int, str, None]</code> <p>Memory limit, valid values are <code>1024</code> (ints are bytes) or <code>\"43m\"</code> or <code>\"6g\"</code>.</p> <code>None</code> <code>memory_reservation</code> <code>Union[int, str, None]</code> <p>Memory soft limit</p> <code>None</code> <code>memory_swap</code> <code>Union[int, str, None]</code> <p>Swap limit equal to memory plus swap: '-1' to enable unlimited swap.</p> <code>None</code> <code>pids_limit</code> <code>Optional[int]</code> <p>Tune container pids limit (set <code>-1</code> for unlimited)</p> <code>None</code> <code>restart</code> <code>Optional[str]</code> <p>Restart policy to apply when a container exits (default \"no\")</p> <code>None</code>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.update--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.wait","title":"wait","text":"<pre><code>wait(x)\n</code></pre> <p>Block until one or more containers stop, then returns their exit codes</p> <p>Alias: <code>docker.wait(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidContainer, List[ValidContainer]]</code> <p>One or a list of containers to wait for.</p> required"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.wait--returns","title":"Returns","text":"<pre><code>An `int` if a single container was passed as argument or a list of ints\nif multiple containers were passed as arguments.\n</code></pre> <p>Some Examples:</p> <pre><code>cont = docker.run(\"ubuntu\", [\"bash\", \"-c\", \"sleep 2 &amp;&amp; exit 8\"], detach=True)\n\nexit_code = docker.wait(cont)\n\nprint(exit_code)\n# 8\ndocker.container.remove(cont)\n</code></pre> <pre><code>cont_1 = docker.run(\"ubuntu\", [\"bash\", \"-c\", \"sleep 4 &amp;&amp; exit 8\"], detach=True)\ncont_2 = docker.run(\"ubuntu\", [\"bash\", \"-c\", \"sleep 2 &amp;&amp; exit 10\"], detach=True)\n\nexit_codes = docker.wait([cont_1, cont_2])\n\nprint(exit_codes)\n# [8, 10]\ndocker.container.remove([cont_1, cont_2])\n</code></pre>"},{"location":"sub-commands/container/#python_on_whales.components.container.cli_wrapper.ContainerCLI.wait--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchContainer` if the container does not exists.\n</code></pre>"},{"location":"sub-commands/context/","title":"docker context","text":""},{"location":"sub-commands/context/#how-to-use-docker-contexts","title":"How to use Docker contexts","text":"<p>Docker contexts allow you to connect to docker daemons other than the local one. This is similar to the <code>-H</code> argument of the Docker command.</p> <p>Contexts commands allow you to declare, save, list local and remote Docker daemons and Kubernetes endpoints that you have.</p> <p>An exemple here with python-on-whales:</p> <pre><code>from python_on_whales import docker, DockerContextConfig\n\nnew_context = docker.context.create(\n    \"my_remote_ssh_server\",\n    docker=DockerContextConfig(host=\"ssh://ubuntu@52.57.163.75\"),\n    description=\"my server ssh with a lot more power\"\n)\nprint(docker.context.list())\n# [python_on_whales.Context(name='default', endpoints={'docker': ContextEndpoint(host='unix:///var/run/docker.sock', skip_tls_verify=False)}),\n# python_on_whales.Context(name='my_remote_ssh_server', endpoints={'docker': ContextEndpoint(host='ssh://ubuntu@52.57.163.75', skip_tls_verify=False)})]\nnew_context.use()\n# it's the same to use docker.context.use(\"my_remote_ssh_server\") or docker.context.use(new_context)\n\nprint(docker.ps()) # will list the containers in the remote server\n# [python_on_whales.Container(id=...), python_on_whales.Container(id=...)]\n# return to the local docker daemon\ndocker.context.use(\"default\")\nprint(docker.ps()) # will list the containers running locally\n# [python_on_whales.Container(id=...)]\n</code></pre> <p>Note that for this simple use case, it's equivalent to use the <code>-H</code> option of the Docker client like so:</p> <pre><code>from python_on_whales import DockerClient\n\ndocker = DockerClient(host=\"ssh://ubuntu@52.57.163.75\")\n\nprint(docker.ps())\n</code></pre>"},{"location":"sub-commands/context/#python_on_whales.components.context.cli_wrapper.ContextCLI","title":"ContextCLI","text":""},{"location":"sub-commands/context/#python_on_whales.components.context.cli_wrapper.ContextCLI.create","title":"create","text":"<pre><code>create(context_name, default_stack_orchestrator=None, description=None, from_=None, docker=None, kubernetes=None)\n</code></pre> <p>Creates a new context</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <p>name of the context to create</p> required <code>default_stack_orchestrator</code> <code>Optional[str]</code> <p>Default orchestrator for stack operations to use with this context (swarm|kubernetes|all)</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>Description of the context</p> <code>None</code> <code>docker</code> <code>Union[Dict[str, Any], DockerContextConfig, None]</code> <p>Set the docker endpoint, you can use a dict of a class to specify the options. The class is <code>python_on_whales.DockerContextConfig</code>.</p> <code>None</code> <code>from_</code> <code>Optional[ValidContext]</code> <p>Create context from a named context</p> <code>None</code> <code>kubernetes</code> <code>Union[Dict[str, Any], KubernetesContextConfig, None]</code> <p>Set the kubernetes endpoint. You can use a dict or a class to specify the options. The class is <code>python_on_whales.KubernetesContextConfig</code>.</p> <code>None</code>"},{"location":"sub-commands/context/#python_on_whales.components.context.cli_wrapper.ContextCLI.inspect","title":"inspect","text":"<pre><code>inspect(x=None)\n</code></pre> <p>Returns the context object. If no argument is provided, returns the current context.</p>"},{"location":"sub-commands/context/#python_on_whales.components.context.cli_wrapper.ContextCLI.list","title":"list","text":"<pre><code>list()\n</code></pre> <p>List all Docker contexts available</p>"},{"location":"sub-commands/context/#python_on_whales.components.context.cli_wrapper.ContextCLI.list--returns","title":"Returns","text":"<pre><code>`List[python_on_whales.Context]`\n</code></pre>"},{"location":"sub-commands/context/#python_on_whales.components.context.cli_wrapper.ContextCLI.remove","title":"remove","text":"<pre><code>remove(x, force=False)\n</code></pre> <p>Removes one or more contexts</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidContext, List[ValidContext]]</code> <p>One or more contexts, empty list means no-op.</p> required <code>force</code> <code>bool</code> <p>Force the removal of this context</p> <code>False</code>"},{"location":"sub-commands/context/#python_on_whales.components.context.cli_wrapper.ContextCLI.update","title":"update","text":"<pre><code>update()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/context/#python_on_whales.components.context.cli_wrapper.ContextCLI.use","title":"use","text":"<pre><code>use(context)\n</code></pre> <p>Set the default context</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ValidContext</code> <p>The context to set as default</p> required"},{"location":"sub-commands/image/","title":"docker image","text":""},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI","title":"ImageCLI","text":""},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.exists","title":"exists","text":"<pre><code>exists(x)\n</code></pre> <p>Returns <code>True</code> if the image exists. <code>False</code> otherwise.</p> <p>It's just calling <code>docker.image.inspect(...)</code> and verifies that it doesn't throw  a <code>python_on_whales.exceptions.NoSuchImage</code>.</p>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.exists--returns","title":"Returns","text":"<pre><code>A `bool`\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.history","title":"history","text":"<pre><code>history()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.import_","title":"import_","text":"<pre><code>import_(source, tag=None, changes=[], message=None, platform=None)\n</code></pre> <p>Import the contents from a tarball to create a filesystem image</p> <p>Alias: <code>docker.import_(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>changes</code> <code>List[str]</code> <p>Apply Dockerfile instruction to the created image</p> <code>[]</code> <code>message</code> <code>Optional[str]</code> <p>Set commit message for imported image</p> <code>None</code> <code>platform</code> <code>Optional[str]</code> <p>Set platform if server is multi-platform capable</p> <code>None</code>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Creates a <code>python_on_whales.Image</code> object.</p>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.inspect--returns","title":"Returns","text":"<pre><code>`python_on_whales.Image`, or `List[python_on_whales.Image]` if the input\nwas a list of strings.\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.inspect--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchImage` if one of the images does not exists.\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.legacy_build","title":"legacy_build","text":"<pre><code>legacy_build(context_path, add_hosts={}, build_args={}, cache=True, file=None, labels={}, network=None, pull=False, tags=[], target=None)\n</code></pre> <p>Build a Docker image with the old Docker builder (meaning not using buildx/buildkit)</p> <p>As the name implies this is a legacy building method. Users are strongly encouraged to use <code>docker.build()</code> instead. The legacy builder will not be available in docker v22.06 and above.</p> <p>This function also won't run the legacy builder if the environment variable <code>DOCKER_BUILDKIT</code> is set to <code>1</code> or if you had run previously <code>docker buildx install</code> from bash or <code>docker.buildx.install()</code> from Python.</p> <p>Some resources on why moving to buildx/buildkit is necessary:</p> <ul> <li>Proposal: make BuildKit the default builder on Linux</li> <li>Deprecated Engine Features: Legacy builder for Linux images</li> </ul> <p>A <code>python_on_whales.Image</code> is returned, even when using multiple tags. That is because it will produce a single image with multiple tags.</p> <p>Parameters:</p> Name Type Description Default <code>context_path</code> <code>ValidPath</code> <p>The path of the build context. Defaults to the current working directory</p> required <code>add_hosts</code> <code>Dict[str, str]</code> <p>Hosts to add. <code>add_hosts={\"my_host1\": \"192.168.32.35\"}</code></p> <code>{}</code> <code>build_args</code> <code>Dict[str, str]</code> <p>The build arguments. ex <code>build_args={\"PY_VERSION\": \"3.7.8\", \"UBUNTU_VERSION\": \"20.04\"}</code>.</p> <code>{}</code> <code>cache</code> <code>bool</code> <p>Whether or not to use the cache, defaults to True</p> <code>True</code> <code>file</code> <code>Optional[ValidPath]</code> <p>The path of the Dockerfile, defaults to <code>context_path/Dockerfile</code></p> <code>None</code> <code>labels</code> <code>Dict[str, str]</code> <p>Dict of labels to add to the image. <code>labels={\"very-secure\": \"1\", \"needs-gpu\": \"0\"}</code> for example.</p> <code>{}</code> <code>network</code> <code>Optional[str]</code> <p>which network to use when building the Docker image</p> <code>None</code> <code>pull</code> <code>bool</code> <p>Always attempt to pull a newer version of the image</p> <code>False</code> <code>tags</code> <code>Union[str, List[str]]</code> <p>Tag or tags to put on the resulting image.</p> <code>[]</code> <code>target</code> <code>Optional[str]</code> <p>Set the target build stage to build.</p> <code>None</code>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.legacy_build--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Image`\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.list","title":"list","text":"<pre><code>list(repository_or_tag=None, filters={}, all=False)\n</code></pre> <p>Returns the list of Docker images present on the machine.</p> <p>Alias: <code>docker.images()</code></p> <p>Note that each image may have multiple tags.</p>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.list--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Image]` object.\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.load","title":"load","text":"<pre><code>load(input, quiet=False)\n</code></pre> <p>Loads one or multiple Docker image(s) from a tar or an iterator of <code>bytes</code>.</p> <p>Alias: <code>docker.load(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>Union[ValidPath, bytes, Iterator[bytes]]</code> <p>Path or input stream to load the images from.</p> required <code>quiet</code> <code>bool</code> <p>If you don't want to display the progress bars.</p> <code>False</code>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.load--returns","title":"Returns","text":"<pre><code>`None` when using bytes as input. A `List[str]` (list of tags)\n when a path is provided.\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.prune","title":"prune","text":"<pre><code>prune(all=False, filter={})\n</code></pre> <p>Remove unused images</p> <p>Parameters:</p> Name Type Description Default <code>all</code> <code>bool</code> <p>Remove all unused images, not just dangling ones</p> <code>False</code> <code>filter</code> <code>Dict[str, str]</code> <p>Provide filter values (e.g. <code>{\"until\": \"&lt;timestamp&gt;\"}</code>)</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The output of the CLI (the layers removed).</p>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.pull","title":"pull","text":"<pre><code>pull(x, quiet=False)\n</code></pre> <p>Pull one or more docker image(s)</p> <p>Alias: <code>docker.pull(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[str, List[str]]</code> <p>The image name(s) . Can be a string or a list of strings. In case of list, multithreading is used to pull the images. The progress bars might look strange as multiple processes are drawing on the terminal at the same time.</p> required <code>quiet</code> <code>bool</code> <p>If you don't want to see the progress bars.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[Image, List[Image]]</code> <p>The Docker image loaded (<code>python_on_whales.Image</code> object).</p> <code>Union[Image, List[Image]]</code> <p>If a list was passed as input, then a <code>List[python_on_whales.Image]</code> will</p> <code>Union[Image, List[Image]]</code> <p>be returned.</p>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.push","title":"push","text":"<pre><code>push(x, quiet=False)\n</code></pre> <p>Push a tag or a repository to a registry</p> <p>Alias: <code>docker.push(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[str, List[str]]</code> <p>Tag(s) or repo(s) to push. Can be a string or a list of strings. If it's a list of string, python-on-whales will push all the images with multiple threads. The progress bars might look strange as multiple processes are drawing on the terminal at the same time.</p> required <code>quiet</code> <code>bool</code> <p>If you don't want to see the progress bars.</p> <code>False</code>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.push--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchImage` if one of the images does not exists.\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.remove","title":"remove","text":"<pre><code>remove(x, force=False, prune=True)\n</code></pre> <p>Remove one or more docker images.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidImage, List[ValidImage]]</code> <p>Single image or list of Docker images to remove. You can use tags or <code>python_on_whales.Image</code> objects.</p> required <code>force</code> <code>bool</code> <p>Force removal of the image</p> <code>False</code> <code>prune</code> <code>bool</code> <p>Delete untagged parents</p> <code>True</code>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.remove--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchImage` if one of the images does not exists.\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.save","title":"save","text":"<pre><code>save(images, output=None)\n</code></pre> <p>Save one or more images to a tar archive. Returns a stream if output is <code>None</code></p> <p>Alias: <code>docker.save(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>Union[ValidImage, List[ValidImage]]</code> <p>Single docker image or list of docker images to save</p> required <code>output</code> <code>Optional[ValidPath]</code> <p>Path of the tar archive to produce. If <code>output</code> is None, a generator of bytes is produced. It can be used to stream those bytes elsewhere, to another Docker daemon for example.</p> <code>None</code>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.save--returns","title":"Returns","text":"<pre><code>`Optional[Iterator[bytes]]`. If output is a path, nothing is returned.\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.save--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchImage` if one of the images does not exists.\n</code></pre>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.save--example","title":"Example","text":"<p>An example of transfer of an image from a local Docker daemon to a remote Docker daemon. We assume that the remote machine has an ssh access:</p> <pre><code>from python_on_whales import DockerClient\n\nlocal_docker = DockerClient()\nremote_docker = DockerClient(host=\"ssh://my_user@186.167.32.84\")\n\nimage_name = \"busybox:1\"\nlocal_docker.pull(image_name)\nbytes_iterator = local_docker.image.save(image_name)\n\nremote_docker.image.load(bytes_iterator)\n</code></pre> <p>Of course the best solution is to use a registry to transfer image but it's a cool example nonetheless.</p>"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.tag","title":"tag","text":"<pre><code>tag(source_image, new_tag)\n</code></pre> <p>Adds a tag to a Docker image.</p> <p>Alias: <code>docker.tag(...)</code></p> <p>Parameters:</p> Name Type Description Default <code>source_image</code> <code>Union[Image, str]</code> <p>The Docker image to tag. You can use a tag to reference it.</p> required <code>new_tag</code> <code>str</code> <p>The tag to add to the Docker image.</p> required"},{"location":"sub-commands/image/#python_on_whales.components.image.cli_wrapper.ImageCLI.tag--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchImage` if the image does not exists.\n</code></pre>"},{"location":"sub-commands/manifest/","title":"docker manifest","text":""},{"location":"sub-commands/manifest/#python_on_whales.components.manifest.cli_wrapper.ManifestCLI","title":"ManifestCLI","text":""},{"location":"sub-commands/manifest/#python_on_whales.components.manifest.cli_wrapper.ManifestCLI.annotate","title":"annotate","text":"<pre><code>annotate(name, manifest, arch=None, os=None, os_features=None, os_version=None, variant=None)\n</code></pre> <p>Annotates a Docker manifest list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the manifest list</p> required <code>manifest</code> <code>str</code> <p>The individual manifest to annotate</p> required <code>arch</code> <code>Optional[str]</code> <p>The manifest's architecture</p> <code>None</code> <code>os</code> <code>Optional[str]</code> <p>The manifest's operating system</p> <code>None</code> <code>os_features</code> <code>Optional[List[str]]</code> <p>The manifest's operating system features</p> <code>None</code> <code>os_version</code> <code>Optional[str]</code> <p>The manifest's operating system version</p> <code>None</code> <code>variant</code> <code>Optional[str]</code> <p>The manifest's architecture variant</p> <code>None</code>"},{"location":"sub-commands/manifest/#python_on_whales.components.manifest.cli_wrapper.ManifestCLI.create","title":"create","text":"<pre><code>create(name, manifests, ammend=False, insecure=False)\n</code></pre> <p>Creates a Docker manifest list.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the manifest list</p> required <code>manifests</code> <code>List[str]</code> <p>The list of manifests to add to the manifest list</p> required"},{"location":"sub-commands/manifest/#python_on_whales.components.manifest.cli_wrapper.ManifestCLI.create--returns","title":"Returns","text":"<pre><code>A `python_on_whales.ManifestList`.\n</code></pre>"},{"location":"sub-commands/manifest/#python_on_whales.components.manifest.cli_wrapper.ManifestCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Returns a Docker manifest list object.</p>"},{"location":"sub-commands/manifest/#python_on_whales.components.manifest.cli_wrapper.ManifestCLI.push","title":"push","text":"<pre><code>push(x, purge=False, quiet=False)\n</code></pre> <p>Push a manifest list to a repository.</p>"},{"location":"sub-commands/manifest/#python_on_whales.components.manifest.cli_wrapper.ManifestCLI.push--options","title":"Options","text":"<pre><code>purge: Remove the local manifest list after push\n</code></pre>"},{"location":"sub-commands/manifest/#python_on_whales.components.manifest.cli_wrapper.ManifestCLI.remove","title":"remove","text":"<pre><code>remove(manifest_lists)\n</code></pre> <p>Removes a Docker manifest list or lists.</p> <p>Parameters:</p> Name Type Description Default <code>manifest_lists</code> <code>Union[ValidManifestList, List[ValidManifestList]]</code> <p>One or more manifest lists.</p> required"},{"location":"sub-commands/network/","title":"docker network","text":""},{"location":"sub-commands/network/#python_on_whales.components.network.cli_wrapper.NetworkCLI","title":"NetworkCLI","text":""},{"location":"sub-commands/network/#python_on_whales.components.network.cli_wrapper.NetworkCLI.connect","title":"connect","text":"<pre><code>connect(network, container, alias=None, driver_options=[], ip=None, ip6=None, links=[])\n</code></pre> <p>Connect a container to a network</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>ValidNetwork</code> <p>The network to connect to</p> required <code>container</code> <code>python_on_whales.components.container.cli_wrapper.ValidContainer</code> <p>The container to connect</p> required <code>alias</code> <code>Optional[str]</code> <p>Add network-scoped alias for the container</p> <code>None</code> <code>driver_options</code> <code>List[str]</code> <p>Driver options for the network</p> <code>[]</code> <code>ip</code> <code>Optional[str]</code> <p>IPv4 address (e.g., <code>\"172.30.100.104\"</code>)</p> <code>None</code> <code>ip6</code> <code>Optional[str]</code> <p>IPv6 address (e.g., <code>\"2001:db8::33\"</code>)</p> <code>None</code> <code>links</code> <code>List[python_on_whales.components.container.cli_wrapper.ValidContainer]</code> <p>Add links to other containers</p> <code>[]</code>"},{"location":"sub-commands/network/#python_on_whales.components.network.cli_wrapper.NetworkCLI.create","title":"create","text":"<pre><code>create(name, attachable=False, driver=None, gateway=None, subnet=None, labels={}, options=[])\n</code></pre> <p>Creates a Docker network.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the network</p> required"},{"location":"sub-commands/network/#python_on_whales.components.network.cli_wrapper.NetworkCLI.create--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Network`.\n</code></pre>"},{"location":"sub-commands/network/#python_on_whales.components.network.cli_wrapper.NetworkCLI.disconnect","title":"disconnect","text":"<pre><code>disconnect(network, container, force=False)\n</code></pre> <p>Disconnect a container from a network</p> <p>Parameters:</p> Name Type Description Default <code>network</code> <code>ValidNetwork</code> <p>The name of the network.</p> required <code>container</code> <code>python_on_whales.components.container.cli_wrapper.ValidContainer</code> <p>The container to disconnect.</p> required"},{"location":"sub-commands/network/#python_on_whales.components.network.cli_wrapper.NetworkCLI.remove","title":"remove","text":"<pre><code>remove(networks)\n</code></pre> <p>Removes a Docker network</p> <p>Parameters:</p> Name Type Description Default <code>networks</code> <code>Union[ValidNetwork, List[ValidNetwork]]</code> <p>One or more networks.</p> required"},{"location":"sub-commands/node/","title":"docker node","text":""},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI","title":"NodeCLI","text":""},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.demote","title":"demote","text":"<pre><code>demote(x)\n</code></pre> <p>Demote one or more nodes from manager in the swarm</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidNode, List[ValidNode]]</code> <p>One or a list of nodes.</p> required"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Returns a <code>python_on_whales.Node</code> object from a string (id or hostname of the node)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[str, List[str]]</code> <p>One id or hostname or a list of ids or hostnames</p> required"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.inspect--returns","title":"Returns","text":"<pre><code>One or a list of `python_on_whales.Node`\n</code></pre>"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.list","title":"list","text":"<pre><code>list()\n</code></pre> <p>Returns the list of nodes in this swarm.</p>"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.list--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Node]`\n</code></pre>"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.promote","title":"promote","text":"<pre><code>promote(x)\n</code></pre> <p>Promote one or more nodes to manager in the swarm</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidNode, List[ValidNode]]</code> <p>One or a list of nodes.</p> required"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.ps","title":"ps","text":"<pre><code>ps(x=None)\n</code></pre> <p>Returns the list of swarm tasks running on one or more nodes.</p> <pre><code>from python_on_whales import docker\n\ntasks = docker.node.ps(\"my-node-name\")\nprint(tasks[0].desired_state)\n# running\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidNode, List[ValidNode], None]</code> <p>One or more nodes (can be id, name or <code>python_on_whales.Node</code> object.). If the argument is not provided, it defaults to the current node. An empty list means an empty list will also be returned.</p> <code>None</code>"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.ps--returns","title":"Returns","text":"<pre><code>`List[python_on_whales.Task]`\n</code></pre>"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.remove","title":"remove","text":"<pre><code>remove(x, force=False)\n</code></pre> <p>Remove one or more nodes from the swarm</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidNode, List[ValidNode]]</code> <p>One node or a list of nodes. You can use the id or the hostname of a node. You can also use a <code>python_on_whales.Node</code>.</p> required <code>force</code> <code>bool</code> <p>Force remove a node from the swarm</p> <code>False</code>"},{"location":"sub-commands/node/#python_on_whales.components.node.cli_wrapper.NodeCLI.update","title":"update","text":"<pre><code>update(node, availability=None, labels_add={}, rm_labels=[], role=None)\n</code></pre> <p>Updates a Swarm node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>ValidNode</code> <p>The node to update, you can use a string or a <code>python_on_whales.Node</code> object.</p> required <code>availability</code> <code>Optional[str]</code> <p>Availability of the node (\"active\"|\"pause\"|\"drain\")</p> <code>None</code> <code>labels_add</code> <code>Dict[str, str]</code> <p>Remove a node label if exists</p> <code>{}</code> <code>rm_labels</code> <code>List[str]</code> <p>Labels to remove from the node.</p> <code>[]</code> <code>role</code> <code>Optional[str]</code> <p>Role of the node (\"worker\"|\"manager\")</p> <code>None</code>"},{"location":"sub-commands/plugin/","title":"docker plugin","text":""},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI","title":"PluginCLI","text":""},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.create","title":"create","text":"<pre><code>create(plugin_name, plugin_data_directory, compress=False)\n</code></pre> <p>Create a plugin from a rootfs and configuration.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>The name you want to give to your plugin</p> required <code>plugin_data_directory</code> <code>ValidPath</code> <p>Must contain config.json and rootfs directory.</p> required <code>compress</code> <code>bool</code> <p>Compress the context using gzip</p> <code>False</code>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.disable","title":"disable","text":"<pre><code>disable(plugin, force=False)\n</code></pre> <p>Disable a plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>ValidPlugin</code> <p>The plugin to disable</p> required <code>force</code> <code>bool</code> <p>Force the disable of an active plugin</p> <code>False</code>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.enable","title":"enable","text":"<pre><code>enable(plugin, timeout=None)\n</code></pre> <p>Enable a plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>ValidPlugin</code> <p>The plugin to enable</p> required <code>timeout</code> <code>int</code> <p>HTTP client timeout (in seconds) (default 30)</p> <code>None</code>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Returns a <code>python_on_whales.Plugin</code> object from a string (name or id of the plugin)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[str, List[str]]</code> <p>One id or hostname or a list of name or ids</p> required"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.inspect--returns","title":"Returns","text":"<pre><code>One or a list of `python_on_whales.Plugin`\n</code></pre>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.install","title":"install","text":"<pre><code>install(plugin_name, configuration={}, alias=None, disable=False, disable_content_trust=True)\n</code></pre> <p>Installs a Docker plugin</p> <p>Warning: <code>--grant-all-permissions</code> is enabled, which means the program won't stop to ask you to grant the permissions.</p> <p>Parameters:</p> Name Type Description Default <code>plugin_name</code> <code>str</code> <p>The name of the plugin you want to install</p> required <code>configuration</code> <code>Dict[str, str]</code> <p>A <code>dict</code> adding configuration options to the plugin</p> <code>{}</code> <code>alias</code> <code>Optional[str]</code> <p>Local name for plugin</p> <code>None</code> <code>disable</code> <code>bool</code> <p>Do not enable the plugin on install</p> <code>False</code> <code>disable_content_trust</code> <code>bool</code> <p>Skip image verification (default <code>True</code>)</p> <code>True</code>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.install--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Plugin`.\n</code></pre>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.list","title":"list","text":"<pre><code>list()\n</code></pre> <p>Returns a <code>List[python_on_whales.Plugin</code> that are installed on the daemon.</p>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.push","title":"push","text":"<pre><code>push(plugin, disable_content_trust=True)\n</code></pre> <p>Push a plugin to a registry.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>ValidPlugin</code> <p>The plugin to push</p> required <code>disable_content_trust</code> <code>bool</code> <p>Skip image signing (default <code>True</code>)</p> <code>True</code>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.remove","title":"remove","text":"<pre><code>remove(x, force=False)\n</code></pre> <p>Removes one or more plugins</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <p>One or more plugins to remove.</p> required <code>force</code> <code>bool</code> <p>Force the removal of this plugin.</p> <code>False</code>"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.set","title":"set","text":"<pre><code>set(plugin, configuration)\n</code></pre> <p>Change the settings for a plugin</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>ValidPlugin</code> <p>The plugin that needs its settings changed</p> required <code>configuration</code> <code>Dict[str, str]</code> <p>The new configuration options.</p> required"},{"location":"sub-commands/plugin/#python_on_whales.components.plugin.cli_wrapper.PluginCLI.upgrade","title":"upgrade","text":"<pre><code>upgrade(plugin, remote=None, disable_content_trust=True, skip_remote_check=False)\n</code></pre> <p>Upgrade a plugin</p> <p>Warning: <code>--grant-all-permissions</code> is enabled, which means the program won't stop to ask you to grant the permissions.</p> <p>Parameters:</p> Name Type Description Default <code>plugin</code> <code>ValidPlugin</code> <p>The plugin to upgrade</p> required <code>remote</code> <code>Optional[str]</code> <p>The remote to fetch the upgrade from</p> <code>None</code> <code>disable_content_trust</code> <code>bool</code> <p>Skip image verification (default <code>True</code>)</p> <code>True</code> <code>skip_remote_check</code> <code>bool</code> <p>Do not check if specified remote plugin matches existing plugin image</p> <code>False</code>"},{"location":"sub-commands/secret/","title":"docker secret","text":""},{"location":"sub-commands/secret/#python_on_whales.components.secret.cli_wrapper.SecretCLI","title":"SecretCLI","text":""},{"location":"sub-commands/secret/#python_on_whales.components.secret.cli_wrapper.SecretCLI.create","title":"create","text":"<pre><code>create(name, file, driver=None, labels={}, template_driver=None)\n</code></pre> <p>Creates a <code>python_on_whales.Secret</code>.</p>"},{"location":"sub-commands/secret/#python_on_whales.components.secret.cli_wrapper.SecretCLI.create--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Secret` object.\n</code></pre>"},{"location":"sub-commands/secret/#python_on_whales.components.secret.cli_wrapper.SecretCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Returns one or more <code>python_on_whales.Secret</code> based on an ID or name.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[str, List[str]]</code> <p>One or more IDs/names.</p> required"},{"location":"sub-commands/secret/#python_on_whales.components.secret.cli_wrapper.SecretCLI.list","title":"list","text":"<pre><code>list(filters={})\n</code></pre> <p>Returns all secrets as a <code>List[python_on_whales.Secret]</code>.</p>"},{"location":"sub-commands/secret/#python_on_whales.components.secret.cli_wrapper.SecretCLI.remove","title":"remove","text":"<pre><code>remove(x)\n</code></pre> <p>Removes one or more secrets</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidSecret, List[ValidSecret]]</code> <p>One or more secrets. Name, ids or <code>python_on_whales.Secret</code> objects are valid inputs.</p> required"},{"location":"sub-commands/service/","title":"docker service","text":""},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI","title":"ServiceCLI","text":""},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.create","title":"create","text":"<pre><code>create(image, command, cap_add=[], cap_drop=[], constraints=[], detach=False, dns=[], dns_options=[], dns_search=[], endpoint_mode=None, entrypoint=None, envs={}, env_files=[], generic_resources=[], groups=[], healthcheck=True, health_cmd=None, health_interval=None, health_retries=None, health_start_period=None, health_timeout=None, hosts={}, hostname=None, init=False, isolation=None, labels={}, limit_cpu=None, limit_memory=None, limit_pids=None, log_driver=None)\n</code></pre> <p>Creates a Docker swarm service.</p> <p>Consider using 'docker stack deploy' instead as it's idempotent and easier to read for complex applications. docker stack deploy is basically docker compose for swarm clusters.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>The image to use as the base for the service.</p> required <code>command</code> <code>Union[str, List[str], None]</code> <p>The command to execute in the container(s).</p> required"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.exists","title":"exists","text":"<pre><code>exists(x)\n</code></pre> <p>Verify that a service exists.</p> <p>It's just calling <code>docker.service.inspect(...)</code> and verifies that it doesn't throw  a <code>python_on_whales.exceptions.NoSuchService</code>.</p>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.exists--returns","title":"Returns","text":"<pre><code>A `bool`\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Returns one or a list of <code>python_on_whales.Service</code> object(s).</p>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.inspect--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchService` if one of the services\ndoesn't exists.\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.list","title":"list","text":"<pre><code>list()\n</code></pre> <p>Returns the list of services</p>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.list--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Services]`\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.logs","title":"logs","text":"<pre><code>logs(service, details=False, since=None, tail=None, timestamps=False, follow=False, raw=False, task_ids=True, resolve=True, truncate=True, stream=False)\n</code></pre> <p>Returns the logs of a service as a string or an iterator.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>ValidService</code> <p>The service to get the logs of</p> required <code>details</code> <code>bool</code> <p>Show extra details provided to logs</p> <code>False</code> <code>since</code> <code>Union[None, datetime, timedelta]</code> <p>Use a datetime or timedelta to specify the lower date limit for the logs.</p> <code>None</code> <code>tail</code> <code>Optional[int]</code> <p>Number of lines to show from the end of the logs (default all)</p> <code>None</code> <code>timestamps</code> <code>bool</code> <p>Put timestamps next to lines.</p> <code>False</code> <code>follow</code> <code>bool</code> <p>If <code>False</code> (the default), the logs returned are the logs up to the time of the function call. If <code>True</code>, the logs of the container up to the time the service is stopped (removed) are displayed. Which is why you must use the <code>stream</code> option if you use the <code>follow</code> option. Without <code>stream</code>, only a <code>str</code> will be returned, possibly much later in the future (maybe never if the service is never removed). So this option is not possible (You'll get an error if you use follow and not stream). With <code>stream</code>, you'll be able to read the logs in real time and stop whenever you need.</p> <code>False</code> <code>stream</code> <code>bool</code> <p>Similar to the <code>stream</code> argument of <code>docker.run()</code>. This function will then returns and iterator that will yield a tuple <code>(source, content)</code> with <code>source</code> being <code>\"stderr\"</code> or <code>\"stdout\"</code>. <code>content</code> is the content of the line as bytes. Take a look at the user guide to have an example of the output.</p> <code>False</code>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.logs--returns","title":"Returns","text":"<pre><code>`str` if `stream=False` (the default), `Iterable[Tuple[str, bytes]]`\nif `stream=True`.\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.logs--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchService` if the service does not exists.\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.ps","title":"ps","text":"<pre><code>ps(x)\n</code></pre> <p>Returns the list of swarm tasks associated with this service.</p> <p>You can pass multiple services at once at this function.</p> <pre><code>from python_on_whales import docker\n\ntasks = docker.service.ps(\"my-service-name\")\nprint(tasks[0].desired_state)\n# running\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidService, List[ValidService]]</code> <p>One or more services (can be id, name or <code>python_on_whales.Service</code> object.)</p> required"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.ps--returns","title":"Returns","text":"<pre><code>`List[python_on_whales.Task]`\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.ps--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchService` if one of the services\ndoesn't exist.\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.remove","title":"remove","text":"<pre><code>remove(services)\n</code></pre> <p>Removes a service</p> <p>Parameters:</p> Name Type Description Default <code>services</code> <code>Union[ValidService, List[ValidService]]</code> <p>One or a list of services to remove.</p> required"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.remove--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchService` if one of the services\ndoesn't exist.\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.rollback","title":"rollback","text":"<pre><code>rollback()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.scale","title":"scale","text":"<pre><code>scale(new_scales, detach=False)\n</code></pre> <p>Scale one or more services.</p> <p>Parameters:</p> Name Type Description Default <code>new_scales</code> <code>Dict[ValidService, int]</code> <p>Mapping between services and the desired scales. For example you can provide <code>new_scale={\"service1\": 4, \"service2\": 8}</code></p> required <code>detach</code> <code>bool</code> <p>If True, does not wait for the services to converge and return immediately.</p> <code>False</code>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.scale--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchService` if one of the services\ndoesn't exists.\n</code></pre>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.update","title":"update","text":"<pre><code>update(service, detach=False, force=False, image=None, with_registry_authentication=False)\n</code></pre> <p>Update a service</p> <p>More options coming soon</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>ValidService</code> <p>The service to update</p> required <code>detach</code> <code>bool</code> <p>Exit immediately instead of waiting for the service to converge</p> <code>False</code> <code>force</code> <code>bool</code> <p>Force update even if no changes require it</p> <code>False</code> <code>image</code> <code>Optional[str]</code> <p>Service image tag</p> <code>None</code> <code>with_registry_authentication</code> <code>bool</code> <p>Send registry authentication details to swarm agents</p> <code>False</code>"},{"location":"sub-commands/service/#python_on_whales.components.service.cli_wrapper.ServiceCLI.update--raises","title":"Raises","text":"<pre><code>`python_on_whales.exceptions.NoSuchService` if the service doesn't exists.\n</code></pre>"},{"location":"sub-commands/stack/","title":"docker stack","text":""},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI","title":"StackCLI","text":""},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.deploy","title":"deploy","text":"<pre><code>deploy(name, compose_files=[], orchestrator=None, prune=False, resolve_image='always', with_registry_auth=False, env_files=[], variables={})\n</code></pre> <p>Deploys a stack.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the stack to deploy. Mandatory.</p> required <code>compose_files</code> <code>Union[ValidPath, List[ValidPath]]</code> <p>One or more docker-compose files. If there are more than</p> <code>[]</code> <code>orchestrator</code> <code>Optional[str]</code> <p>The orchestrator to use, `\"swarm\" or \"kubernetes\" or \"all\".</p> <code>None</code> <code>prune</code> <code>bool</code> <p>Prune services that are no longer referenced</p> <code>False</code> <code>resolve_image</code> <code>str</code> <p>Query the registry to resolve image digest and supported platforms <code>\"always\"|\"changed\"|\"never\"</code> (default <code>\"always\"</code>). Note that if the registry cannot be queried when using <code>\"always\"</code>, it's going to try to use images present locally on the nodes.</p> <code>'always'</code> <code>with_registry_auth</code> <code>bool</code> <p>Send registry authentication details to Swarm agents. Required if you need to run <code>docker login</code> to pull the docker images in your stack.</p> <code>False</code> <code>env_files</code> <code>List[ValidPath]</code> <p>Similar to <code>.env</code> files in docker-compose. Loads <code>variables</code> from <code>.env</code> files. If both <code>env_files</code> and <code>variables</code> are used, <code>variables</code> have priority. This behavior is similar to the one you would experience with compose.</p> <code>[]</code> <code>variables</code> <code>Dict[str, str]</code> <p>A dict dictating by what to replace the variables declared in the docker-compose files. In the docker CLI, you would use environment variables for this.</p> <code>{}</code>"},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.deploy--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Stack` object.\n</code></pre>"},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.list","title":"list","text":"<pre><code>list()\n</code></pre> <p>Returns a list of <code>python_on_whales.Stack</code></p>"},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.list--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Stack]`.\n</code></pre>"},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.ps","title":"ps","text":"<pre><code>ps(x)\n</code></pre> <p>Returns the list of swarm tasks in this stack.</p> <pre><code>from python_on_whales import docker\n\ntasks = docker.stack.ps(\"my-stack\")\nprint(tasks[0].desired_state)\n# running\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ValidStack</code> <p>A stack . It can be name or a <code>python_on_whales.Stack</code> object.</p> required"},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.ps--returns","title":"Returns","text":"<pre><code>`List[python_on_whales.Task]`\n</code></pre>"},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.remove","title":"remove","text":"<pre><code>remove(x)\n</code></pre> <p>Removes one or more stacks.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidStack, List[ValidStack]]</code> <p>One or more stacks, empty list means nothing will be done.</p> required"},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.services","title":"services","text":"<pre><code>services(stack)\n</code></pre> <p>List the services present in the stack.</p> <p>Parameters:</p> Name Type Description Default <code>stack</code> <code>ValidStack</code> <p>A docker stack or the name of a stack.</p> required"},{"location":"sub-commands/stack/#python_on_whales.components.stack.cli_wrapper.StackCLI.services--returns","title":"Returns","text":"<pre><code>A `List[python_on_whales.Stack]`\n</code></pre>"},{"location":"sub-commands/swarm/","title":"docker swarm","text":""},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI","title":"SwarmCLI","text":""},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI.ca","title":"ca","text":"<pre><code>ca(ca_certificate=None, ca_key=None, certificate_expiry=None, detach=False, external_ca=None, rotate=False)\n</code></pre> <p>Get and rotate the root CA</p> <p>Parameters:</p> Name Type Description Default <code>ca_certificate</code> <code>Optional[ValidPath]</code> <p>Path to the PEM-formatted root CA certificate to use for the new cluster</p> <code>None</code> <code>ca_key</code> <code>Optional[ValidPath]</code> <p>Path to the PEM-formatted root CA key to use for the new cluster</p> <code>None</code> <code>certificate_expiry</code> <code>Union[int, timedelta, None]</code> <p>Validity period for node certificates</p> <code>None</code> <code>detach</code> <code>bool</code> <p>Exit immediately instead of waiting for the root rotation to converge. The function will return <code>None</code>.</p> <code>False</code> <code>external_ca</code> <code>Optional[str]</code> <p>Specifications of one or more certificate signing endpoints</p> <code>None</code> <code>rotate</code> <code>bool</code> <p>Rotate the swarm CA - if no certificate or key are provided, new ones will be generated.</p> <code>False</code>"},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI.init","title":"init","text":"<pre><code>init(advertise_address=None, autolock=False, availability='active', data_path_address=None, data_path_port=None, listen_address=None)\n</code></pre> <p>Initialize a Swarm.</p> <p>If you need the token to join the new swarm from another node, use the <code>docker.swarm.join_token</code> function.</p> <p>A example of how to initialize the whole swarm without leaving the manager if the manager has ssh access to the workers:</p> <pre><code>from python_on_whales import docker, DockerClient\n\nworker_docker = DockerClient(host=\"ssh://worker_linux_user@worker_hostname\")\n# Here the docker variable is connected to the local daemon\n# worker_docker is a connected to the Docker daemon of the\n# worker through ssh, useful to control it without login to the machine\n# manually.\ndocker.swarm.init()\nmy_token = docker.swarm.join_token(\"worker\")  # you can set manager too\nworker_docker.swarm.join(\"manager_hostname:2377\", token=my_token)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>advertise_address</code> <code>Optional[str]</code> <p>Advertised address (format: <code>&lt;ip|interface&gt;[:port]</code>)</p> <code>None</code> <code>autolock</code> <code>bool</code> <p>Enable manager autolocking (requiring an unlock key to start a stopped manager)</p> <code>False</code> <code>availability</code> <code>str</code> <p>Availability of the node (\"active\"|\"pause\"|\"drain\")</p> <code>'active'</code> <code>data_path_address</code> <code>Optional[str]</code> <p>Address or interface to use for data path traffic (format is <code>&lt;ip|interface&gt;</code>)</p> <code>None</code>"},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI.join","title":"join","text":"<pre><code>join(manager_address, advertise_address=None, availability='active', data_path_address=None, listen_address=None, token=None)\n</code></pre> <p>Joins a swarm</p> <p>Parameters:</p> Name Type Description Default <code>manager_address</code> <code>str</code> <p>The address of the swarm manager in the format <code>\"{ip}:{port}\"</code></p> required <code>advertise_address</code> <code>Optional[str]</code> <p>Advertised address (format: [:port]) <code>None</code> <code>availability</code> <code>str</code> <p>Availability of the node (<code>\"active\"</code>|<code>\"pause\"</code>|<code>\"drain\"</code>)</p> <code>'active'</code> <code>data_path_address</code> <code>Optional[str]</code> <p>Address or interface to use for data path traffic (format: ) <code>None</code> <code>listen-address</code> <p>Listen address (format: [:port]) (default 0.0.0.0:2377) required <code>token</code> <code>Optional[str]</code> <p>Token for entry into the swarm, will determine if the node enters the swarm as a manager or a worker.</p> <code>None</code>"},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI.join_token","title":"join_token","text":"<pre><code>join_token(node_type, rotate=False)\n</code></pre> <p>Obtains a token to join the swarm</p> <p>This token can then be used with <code>docker.swarm.join(\"manager:2377\", token=my_token)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node_type</code> <code>str</code> <p><code>\"manager\"</code> or <code>\"worker\"</code></p> required <code>rotate</code> <code>bool</code> <p>Rotate join token</p> <code>False</code>"},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI.leave","title":"leave","text":"<pre><code>leave(force=False)\n</code></pre> <p>Leave the swarm</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>Force this node to leave the swarm, ignoring warnings</p> <code>False</code>"},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI.unlock","title":"unlock","text":"<pre><code>unlock(key)\n</code></pre> <p>Unlock a swarm after the <code>--autolock</code> parameter was used and the daemon restarted.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to unlock the swarm. The key can be obtained on any manager with <code>docker.swarm.unlock_key()</code>.</p> required"},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI.unlock_key","title":"unlock_key","text":"<pre><code>unlock_key(rotate=False)\n</code></pre> <p>Gives you the key needed to unlock the swarm after a manager daemon reboot.</p> <p>Parameters:</p> Name Type Description Default <code>rotate</code> <code>bool</code> <p>Rotate the unlock key.</p> <code>False</code>"},{"location":"sub-commands/swarm/#python_on_whales.components.swarm.cli_wrapper.SwarmCLI.update","title":"update","text":"<pre><code>update(autolock=None, cert_expiry=None, dispatcher_heartbeat=None, external_ca=None, max_snapshots=None, snapshot_interval=None, task_history_limit=None)\n</code></pre> <p>Update the swarm configuration</p> <p>Parameters:</p> Name Type Description Default <code>autolock</code> <code>Optional[bool]</code> <p>Change manager autolocking setting</p> <code>None</code> <code>cert_expiry</code> <code>Optional[timedelta]</code> <p>Validity period for node certificates, default is <code>datetime.timedelta(days=90)</code>. If <code>int</code>, it's a number of seconds.</p> <code>None</code> <code>dispatcher_heartbeat</code> <code>Optional[timedelta]</code> <p>Dispatcher heartbeat period.</p> <code>None</code> <code>external_ca</code> <code>Optional[str]</code> <p>Specifications of one or more certificate signing endpoints</p> <code>None</code> <code>max_snapshots</code> <code>Optional[int]</code> <p>Number of additional Raft snapshots to retain</p> <code>None</code> <code>snapshot_interval</code> <code>Optional[int]</code> <p>Number of log entries between Raft snapshots (default 10000)</p> <code>None</code> <code>task_history_limit</code> <code>Optional[int]</code> <p>Task history retention limit (default 5)</p> <code>None</code>"},{"location":"sub-commands/system/","title":"docker system","text":""},{"location":"sub-commands/system/#python_on_whales.components.system.cli_wrapper.SystemCLI","title":"SystemCLI","text":""},{"location":"sub-commands/system/#python_on_whales.components.system.cli_wrapper.SystemCLI.disk_free","title":"disk_free","text":"<pre><code>disk_free()\n</code></pre> <p>Give information about the disk usage of the Docker daemon.</p> <p>Returns a <code>python_on_whales.DiskFreeResult</code> object.</p> <pre><code>from python_on_whales import docker\ndisk_free_result = docker.system.disk_free()\nprint(disk_free_result.images.active)  #int\nprint(disk_free_result.containers.reclaimable)  # int, number of bytes\nprint(disk_free_result.volumes.reclaimable_percent)  # float\nprint(disk_free_result.build_cache.total_count)  # int\nprint(disk_free_result.build_cache.size)  # int, number of bytes\n...\n</code></pre> <p>Note that the number are not 100% accurate because the docker CLI doesn't provide the exact numbers.</p> <p>Maybe in a future implementation, we can provide exact numbers.</p> <p>Verbose mode is not yet implemented.</p>"},{"location":"sub-commands/system/#python_on_whales.components.system.cli_wrapper.SystemCLI.events","title":"events","text":"<pre><code>events(since=None, until=None, filters={})\n</code></pre> <p>Return docker events information up to the current point in time.</p> <p>If <code>until</code> is not specified, then the iterator returned is infinite. For example</p> <pre><code>from python_on_whales import docker\nfrom datetime import datetime, timedelta\n\n\nfor event in docker.system.events():\n    print(\"new event!\")\n    print(event)\n    # this will never end, that's ok if you want to monitor something\n    # for a long time. You can also use 'break' in the for loop if needed.\n\nfor event in docker.system.events(until=datetime.now() - timedelta(seconds=30)):\n    print(\"some past event\")\n    print(event)\n    # this loop will end, unlike the previous one\n\nfor event in docker.system.events(until=datetime.now() + timedelta(seconds=30)):\n    print(\"some past event\")\n    print(event)\n    # this loop will end in 30 seconds, even if there are no events at all\n\nevents = list(docker.system.events(filters={\"container\": \"mycontainer\"}, until=datetime.now()))\n# the list of all events concerning the container \"mycontainer\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>since</code> <code>Union[None, datetime.datetime, datetime.timedelta]</code> <p>Show all events created since timestamp</p> <code>None</code> <code>until</code> <code>Union[None, datetime.datetime, datetime.timedelta]</code> <p>Stream events until this timestamp</p> <code>None</code> <code>filters</code> <code>Dict[str, str]</code> <p>See the Docker documentation page about filtering .</p> <code>{}</code>"},{"location":"sub-commands/system/#python_on_whales.components.system.cli_wrapper.SystemCLI.events--returns","title":"Returns","text":"<pre><code>A iterator which will yield DockerEvent objects from stdout/stderr\n</code></pre> <p>reference page for system events</p>"},{"location":"sub-commands/system/#python_on_whales.components.system.cli_wrapper.SystemCLI.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Returns diverse information about the Docker client and daemon.</p>"},{"location":"sub-commands/system/#python_on_whales.components.system.cli_wrapper.SystemCLI.info--returns","title":"Returns","text":"<pre><code>A `python_on_whales.SystemInfo` object\n</code></pre> <p>As an example</p> <pre><code>from python_on_whales import docker\n\ninfo = docker.system.info()\nprint(info.images)\n# 40\nprint(info.plugins.volume)\n# [\"local\"}\n...\n</code></pre> <p>You can find all attributes available by looking up the reference page for system info.</p>"},{"location":"sub-commands/system/#python_on_whales.components.system.cli_wrapper.SystemCLI.prune","title":"prune","text":"<pre><code>prune(all=False, volumes=False, filters={})\n</code></pre> <p>Remove unused docker data</p> <p>Parameters:</p> Name Type Description Default <code>all</code> <code>bool</code> <p>Remove all unused images not just dangling ones</p> <code>False</code> <code>volumes</code> <code>bool</code> <p>Prune volumes</p> <code>False</code> <code>filters</code> <code>Dict[str, str]</code> <p>See the Docker documentation page about filtering . For example, <code>filters=dict(until=\"24h\")</code>.</p> <code>{}</code>"},{"location":"sub-commands/task/","title":"docker task","text":""},{"location":"sub-commands/task/#python_on_whales.components.task.cli_wrapper.TaskCLI","title":"TaskCLI","text":""},{"location":"sub-commands/task/#python_on_whales.components.task.cli_wrapper.TaskCLI.inspect","title":"inspect","text":"<pre><code>inspect(x)\n</code></pre> <p>Returns a <code>python_on_whales.Task</code> object from its ID.</p>"},{"location":"sub-commands/task/#python_on_whales.components.task.cli_wrapper.TaskCLI.list","title":"list","text":"<pre><code>list()\n</code></pre> <p>Returns all tasks in the swarm</p>"},{"location":"sub-commands/task/#python_on_whales.components.task.cli_wrapper.TaskCLI.list--returns","title":"Returns","text":"<pre><code>`List[python_on_whales.Task]`\n</code></pre>"},{"location":"sub-commands/task/#python_on_whales.components.task.cli_wrapper.TaskCLI.logs","title":"logs","text":"<pre><code>logs()\n</code></pre> <p>Not Yet implemented</p>"},{"location":"sub-commands/trust/","title":"docker trust","text":""},{"location":"sub-commands/trust/#python_on_whales.components.trust.cli_wrapper.TrustCLI","title":"TrustCLI","text":""},{"location":"sub-commands/trust/#python_on_whales.components.trust.cli_wrapper.TrustCLI.inspect","title":"inspect","text":"<pre><code>inspect()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/trust/#python_on_whales.components.trust.cli_wrapper.TrustCLI.revoke","title":"revoke","text":"<pre><code>revoke()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/trust/#python_on_whales.components.trust.cli_wrapper.TrustCLI.sign","title":"sign","text":"<pre><code>sign()\n</code></pre> <p>Not yet implemented</p>"},{"location":"sub-commands/volume/","title":"docker volume","text":""},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI","title":"VolumeCLI","text":""},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.clone","title":"clone","text":"<pre><code>clone(source, new_volume_name=None, driver=None, labels={}, options={})\n</code></pre> <p>Clone a volume.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ValidVolume</code> <p>The volume to clone</p> required <code>new_volume_name</code> <code>Optional[str]</code> <p>The new volume name. If not given, a random name is chosen.</p> <code>None</code> <code>driver</code> <code>Optional[str]</code> <p>Specify volume driver name (default \"local\")</p> <code>None</code> <code>labels</code> <code>Dict[str, str]</code> <p>Set metadata for a volume</p> <code>{}</code> <code>options</code> <code>Dict[str, str]</code> <p>Set driver specific options</p> <code>{}</code>"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.clone--returns","title":"Returns","text":"<pre><code>A `python_on_whales.Volume`, the new volume.\n</code></pre>"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.copy","title":"copy","text":"<pre><code>copy(source, destination)\n</code></pre> <p>Copy files/folders between a volume and the local filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[ValidPath, VolumePath]</code> <p>If <code>source</code> is a directory/file inside a Docker volume, a tuple <code>(my_volume, path_in_volume)</code> must be provided. The volume can be a <code>python_on_whales.Volume</code> or a volume name as <code>str</code>. The path can be a <code>pathlib.Path</code> or a <code>str</code>. If <code>source</code> is  a local directory, a <code>pathlib.Path</code> or <code>str</code> should be provided. End the source path with <code>/.</code> if you want to copy the directory content in another directory.</p> required <code>destination</code> <code>Union[ValidPath, VolumePath]</code> <p>Same as <code>source</code>.</p> required"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.create","title":"create","text":"<pre><code>create(volume_name=None, driver=None, labels={}, options={})\n</code></pre> <p>Creates a volume</p> <p>Parameters:</p> Name Type Description Default <code>volume_name</code> <code>Optional[str]</code> <p>The volume name, if not provided, a long random string will be used instead.</p> <code>None</code> <code>driver</code> <code>Optional[str]</code> <p>Specify volume driver name (default \"local\")</p> <code>None</code> <code>labels</code> <code>Dict[str, str]</code> <p>Set metadata for a volume</p> <code>{}</code> <code>options</code> <code>Dict[str, str]</code> <p>Set driver specific options</p> <code>{}</code>"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.exists","title":"exists","text":"<pre><code>exists(x)\n</code></pre> <p>Returns <code>True</code> if the volume exists. <code>False</code> otherwise.</p> <p>It's just calling <code>docker.volume.inspect(...)</code> and verifies that it doesn't throw  a <code>python_on_whales.exceptions.NoSuchVolume</code>.</p>"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.exists--returns","title":"Returns","text":"<pre><code>A `bool`\n</code></pre>"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.list","title":"list","text":"<pre><code>list(filters={})\n</code></pre> <p>List volumes</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Dict[str, Union[str, int]]</code> <p>See the Docker documentation page about filtering . An example <code>filters=dict(dangling=1, driver=\"local\")</code>.</p> <code>{}</code>"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.list--returns","title":"Returns","text":"<pre><code>`List[python_on_whales.Volume]`\n</code></pre>"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.prune","title":"prune","text":"<pre><code>prune(filters={})\n</code></pre> <p>Remove volumes</p> <p>Parameters:</p> Name Type Description Default <code>filters</code> <code>Dict[str, Union[str, int]]</code> <p>See the Docker documentation page about filtering . An example <code>filters=dict(dangling=1, driver=\"local\")</code>.</p> <code>{}</code>"},{"location":"sub-commands/volume/#python_on_whales.components.volume.cli_wrapper.VolumeCLI.remove","title":"remove","text":"<pre><code>remove(x)\n</code></pre> <p>Removes one or more volumes</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Union[ValidVolume, List[ValidVolume]]</code> <p>A volume or a list of volumes. An empty list as argument means nothing is done.</p> required"},{"location":"user_guide/docker_run/","title":"The different ways of using docker.run()","text":""},{"location":"user_guide/docker_run/#simple-call","title":"Simple call","text":"<pre><code>from python_on_whales import docker\n\nstdout_as_str = docker.run(\"hello-world\")\nprint(stdout_as_str)\n\n# Hello from Docker!\n# This message shows that your installation appears to be working correctly.\n# ...\n</code></pre> <p>This is the simplest way. The function <code>docker.run(...)</code> returns only when the container  is done and the output (stdout) is returned all at once in a single string.</p> <p>This is very practical for simple use cases, but not so much when you have a container that needs to run for a very long time for example, as you don't get the output in real time.</p>"},{"location":"user_guide/docker_run/#detach-the-container","title":"Detach the container","text":"<pre><code>from python_on_whales import docker\nfrom redis import Redis\n\nredis_container = docker.run(\"redis\", detach=True, publish=[(6379, 6379)])\n# the container is up and listening on port 6379\n\nredis_client = Redis()\nredis_client.set(\"hello\", \"world\")\nprint(redis_client.get(\"hello\"))\n# b'world'\n</code></pre> <p>This is a very simple way to start a container in the background. It will continue running  until the process inside exits. It's useful when running servers for example, because they should never stop.</p>"},{"location":"user_guide/docker_run/#detach-with-the-context-manager","title":"Detach with the context manager","text":"<pre><code>from python_on_whales import docker\nfrom redis import Redis\n\nwith docker.run(\"redis\", detach=True, publish=[(6379, 6379)]) as redis_container:\n    # the container is up and listening on port 6379\n    redis_client = Redis()\n    redis_client.set(\"hello\", \"world\")\n    print(redis_client.get(\"hello\"))\n    # b'world'\n\nprint(\"The container is now stopped and removed because we're outside the context manager\")\nprint(redis_container.state.running)  # will raise an error with the message \"no such container\"\n</code></pre> <p>Using the context manager is quite useful when you need the container running in the background but you need to know exactly for how long it will live.</p> <p>For example in unit tests, you might need a redis server to execute a function.  You can then have the redis container running only during this specific unit test.</p> <p>This is also better than calling manually <code>redis_container.remove()</code>. Why?  For the same reason it's better to do <code>with open(...) as f:</code> than <code>f = open(...)</code>. If an exception occurs  in the context manager block, the container is still removed.</p>"},{"location":"user_guide/docker_run/#stream-the-output","title":"Stream the output","text":"<pre><code>from python_on_whales import docker\n\noutput_generator = docker.run(\"busybox\", [\"ping\", \"-c\", \"50\", \"www.google.com\"], stream=True, name=\"box\")\n\nfor stream_type, stream_content in output_generator:\n    print(f\"Stream type: {stream_type}, stream content: {stream_content}\")\n\n# Stream type: stdout, stream content: b'PING www.google.com (142.250.74.228): 56 data bytes\\n'\n# Stream type: stdout, stream content: b'64 bytes from 142.250.74.228: seq=0 ttl=119 time=18.350 ms\\n'\n# Stream type: stdout, stream content: b'64 bytes from 142.250.74.228: seq=1 ttl=119 time=18.386 ms\\n'\n# ...\n# Stream type: stdout, stream content: b'64 bytes from 142.250.74.228: seq=48 ttl=119 time=18.494 ms\\n'\n# Stream type: stdout, stream content: b'64 bytes from 142.250.74.228: seq=49 ttl=119 time=18.260 ms\\n'\n# Stream type: stdout, stream content: b'\\n'\n# Stream type: stdout, stream content: b'--- www.google.com ping statistics ---\\n'\n# Stream type: stdout, stream content: b'50 packets transmitted, 50 packets received, 0% packet loss\\n'\n# Stream type: stdout, stream content: b'round-trip min/avg/max = 17.547/18.075/18.508 ms\\n'\n\n# when the generator is done and we're out of the loop\n# it means the container has finished running.\nprint(docker.container.inspect(\"box\").state.running)\n# False\n</code></pre> <p>This is very useful for long running processes. For example if you need the output  of a container that will stay up for a very long time.</p>"},{"location":"user_guide/exceptions/","title":"Capturing exceptions","text":""},{"location":"user_guide/exceptions/#exception-classes","title":"Exception classes","text":"<p>Exceptions raised will be an instance of <code>DockerException</code>, or a child class for more specific errors.</p> <p>Those are the child classes:</p> <ul> <li><code>NoSuchContainer</code></li> <li><code>NoSuchImage</code></li> <li><code>NoSuchService</code></li> <li><code>NotASwarmManager</code></li> <li><code>NoSuchVolume</code></li> </ul> <p>All exceptions will have these 4 attributes:</p> <ul> <li>docker_command: the docker command used internally, as a list of strings.</li> <li>return_code: the exit code docker client exited with, as an int</li> <li>stdout: the content that docker wrote to stdout, as a string, or <code>None</code></li> <li>stderr: the content that docker wrote to stderr, as a string, or <code>None</code></li> </ul>"},{"location":"user_guide/exceptions/#example","title":"Example","text":"<pre><code>import logging\nfrom python_on_whales import DockerClient\nfrom python_on_whales.exceptions import DockerException\n\nclient = DockerClient(compose_files=[\"/tmp/docker-compose.yml\"])\ntry:\n    client.execute(\"my-service\", [\"arg1\", \"arg2\"])\nexcept DockerException as e:\n    print(f\"Exit code {e.return_code} while running {e.docker_command}\")\n</code></pre>"},{"location":"user_guide/generic_resources/","title":"Docker Swarm generic resources","text":"<p>There are two kind of generic resources, discreet and named.</p> <p>Both are declared in <code>/etc/docker/daemon.json</code> and both are  accessible in your containers as environment variables.</p>"},{"location":"user_guide/generic_resources/#named-resources","title":"Named resources","text":"<p>Named resources should be used when you have a small number of things you want accessed. The best example is gpu devices. Each gpu has a UUID, which can be the  name of this resources. Actually you could also use an index, and this index would have  to be the \"name\" of the gpu.</p> <p>Since we want to show they're generic, let's take something else than GPUs for this example.</p> <p>Let's say you have 5 hamsters connected to your node, making an app run:</p> <p> </p> <p>They are named Robert, Lucie, Annie, James and Stacy.</p> <p>You'll define one service that needs one hamster and one that needs three. We'll call them <code>my_light_service</code> and <code>my_heavy_service</code>.</p> <p>Let's declare the hamsters in the <code>/etc/docker/daemon.json</code>. If this file doesn't exist on your system, you can create it.</p> <p>Mine looks like this, note that you don't need the insecure registries part:</p> <pre><code>{\n    \"insecure-registries\": [\"127.0.0.1:5000\"],\n    \"node-generic-resources\": [\n        \"hamster=Robert\",\n        \"hamster=Lucie\",\n        \"hamster=Annie\",\n        \"hamster=James\",\n        \"hamster=Stacy\"\n    ]\n}\n</code></pre> <p>Restart your Docker daemon with <code>sudo service docker restart</code>.</p> <p>Then create a Docker swarm: <code>docker swarm init</code></p> <p>The hamster are declared, up and ready to go!  You can check they're here with <code>docker node ls</code> and <code>docker node inspect</code>.</p>"},{"location":"user_guide/generic_resources/#creating-services-with-the-cli","title":"Creating services with the CLI","text":"<p>It's time to create services and hit those hamsters!</p> <p>First we'll create the services with the CLI and then with the command line.</p> <pre><code>$ docker service create --generic-resource \"hamster=1\" --name my_light_service ubuntu bash -c \"env &amp;&amp; sleep infinity\"\n$ docker service create --generic-resource \"hamster=3\" --name my_heavy_service ubuntu bash -c \"env &amp;&amp; sleep infinity\"\n</code></pre> <p>We have one replica for the light and heavy service. They use 4 hamster. Let's try to use moooooooore!</p> <pre><code>$ docker service scale -d my_light_service=10 my_heavy_service=10\n$ docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\ntt436bxjtdn7        my_heavy_service    replicated          1/10                 ubuntu:latest\nksiq5x0bxch1        my_light_service    replicated          2/10                 ubuntu:latest\n</code></pre> <p>Remember, we only have 5 hamsters, and 3 are needed for the heavy service and one for the light service. Hence here 2 * 1 + 1 * 3 = 5 ! This is what we wanted. So how does each container knows which hamster to use?</p> <p>We asked each container to print the environment variables and sleep for infinity <code>env &amp;&amp; sleep infinity</code>. Let's take a look with <code>docker logs</code>:</p> <pre><code>$ docker ps\nCONTAINER ID IMAGE          COMMAND                NAMES\n1e8932f5a985 ubuntu:latest  \"bash -c 'env &amp;&amp; sle\u2026\" my_light_service.4.shys2wwxz7jjfjg2g2e0xl1sw\n0a5c4ddd303a ubuntu:latest  \"bash -c 'env &amp;&amp; sle\u2026\" my_heavy_service.1.p39satddgf6j1uhspdiohcyzh\ne2872006cc97 ubuntu:latest  \"bash -c 'env &amp;&amp; sle\u2026\" my_light_service.1.bbo0fbi5d5e2zdwozgbse8x57\n\n$ docker logs my_light_service.4.shys2wwxz7jjfjg2g2e0xl1sw\nDOCKER_RESOURCE_HAMSTER=Stacy\nHOSTNAME=1e8932f5a985\n\n$ docker logs my_heavy_service.1.p39satddgf6j1uhspdiohcyzh\nDOCKER_RESOURCE_HAMSTER=Lucie,Annie,James\nHOSTNAME=0a5c4ddd303a\n\n$ docker logs my_light_service.1.bbo0fbi5d5e2zdwozgbse8x57\nDOCKER_RESOURCE_HAMSTER=Robert\nHOSTNAME=e2872006cc97\n</code></pre> <p>So we can see that each container is aware of it's hamster with an environment variable. The process running in the container can grab it and then use the correct hamster without  making two containers use the same hamster.</p>"},{"location":"user_guide/generic_resources/#using-hamsters-with-docker-stack","title":"Using hamsters with Docker stack","text":"<p>Here is a <code>docker-compose.yml</code> that will declare the services exactly like we did in the CLI:</p> <pre><code>version: \"3.8\"\n\nservices:\n  my_light_service:\n    command:\n      - bash\n      - -c\n      - env &amp;&amp; sleep infinity\n    image: ubuntu\n    deploy:\n      replicas: 10\n      resources:\n        reservations:\n          generic_resources:\n            - discrete_resource_spec:\n                kind: 'hamster'\n                value: 1\n\n  my_heavy_service:\n    command:\n      - bash\n      - -c\n      - env &amp;&amp; sleep infinity\n    image: ubuntu\n    deploy:\n      replicas: 10\n      resources:\n        reservations:\n          generic_resources:\n            - discrete_resource_spec:\n                kind: 'hamster'\n                value: 3\n</code></pre> <pre><code>$ docker stack deploy -c docker-compose.yml my_stack_using_hamsters\nCreating network my_stack_using_hamsters_default\nCreating service my_stack_using_hamsters_my_heavy_service\nCreating service my_stack_using_hamsters_my_light_service\n\n$ docker service ls\nID              NAME                                       MODE        REPLICAS  IMAGE \nnlhwfnz0d1cx    my_stack_using_hamsters_my_heavy_service   replicated  1/10      ubuntu:latest\nc77tv3czzfw2    my_stack_using_hamsters_my_light_service   replicated  2/10      ubuntu:latest\n</code></pre>"},{"location":"user_guide/generic_resources/#how-does-that-fit-with-nvidia-gpus","title":"How does that fit with Nvidia GPUs?","text":"<p>Well, if you remember, the Nvidia runtime uses environment variables in the container to know which gpu to use.</p> <p>By modifying the <code>/etc/nvidia-container-runtime/config.toml</code>,  and setting <code>swarm-resource = \"DOCKER_RESOURCE_GPU\"</code>, it indicates the nvidia-docker runtime  that it should watch for this environment variable when deciding which gpu to use. Make the nvidia-docker runtime the default one for this node, replace hamster by gpu and you're good to go as long as you used UUID as your hamster's names.</p> <p>A more in depth guide can be found here.</p>"},{"location":"user_guide/generic_resources/#discreet-resources","title":"Discreet resources","text":"<p>TODO (just put <code>\"node-generic-resources\": [\"hamster=100\"]</code> in the daemon.json, there are too many hamsters to give them names).</p>"},{"location":"user_guide/running_python_on_whales_inside_a_container/","title":"Running python-on-whales inside a container","text":"<p>To follow this example, you just need Docker installed, and nothing else!</p>"},{"location":"user_guide/running_python_on_whales_inside_a_container/#the-use-case","title":"The use case","text":"<p>Sometimes you don't want to install Python on your system, but you still would like to use python-on-whales to handle most of the Docker logic.</p> <p>You can then run python-on-whales inside a Docker container. For simplicity, we let the container access the Docker daemon of the host.</p> <p>Let's give you the code example, and we'll explain afterwards where is the magic.</p>"},{"location":"user_guide/running_python_on_whales_inside_a_container/#example","title":"Example","text":"<p>We want to run this small Python script. It uses python-on-whales. We'll call it <code>main.py</code></p> <pre><code># main.py\nfrom python_on_whales import docker\n\nprint(\"We are going to run the hello world docker container\")\n\noutput = docker.run(\"hello-world\")\n\nprint(\"Here is the output:\")\nprint(output)\n\nprint(f\"buildx version: {docker.buildx.version()}\")\nprint(f\"compose version: {docker.compose.version()}\")\n</code></pre> <p>Next to this <code>main.py</code>, make a <code>Dockerfile</code>.</p> <pre><code># Dockerfile\nFROM python:3.9\n\nRUN pip install python-on-whales\nRUN python-on-whales download-cli\n\n# install docker buildx, this step is optional\nRUN mkdir -p ~/.docker/cli-plugins/\nRUN wget https://github.com/docker/buildx/releases/download/v0.6.3/buildx-v0.6.3.linux-amd64 -O ~/.docker/cli-plugins/docker-buildx\nRUN chmod a+x  ~/.docker/cli-plugins/docker-buildx\n\n# install docker compose, this step is optional\nRUN mkdir -p ~/.docker/cli-plugins/\nRUN wget https://github.com/docker/compose/releases/download/v2.0.1/docker-compose-linux-x86_64 -O ~/.docker/cli-plugins/docker-compose\nRUN chmod a+x  ~/.docker/cli-plugins/docker-compose\n\nCOPY ./main.py /main.py\nCMD python /main.py\n</code></pre> <p>We're all set! Let's run this Python script, without having Python installed on the system!</p> <pre><code>docker build -t image-with-python-on-whales .\ndocker run -v /var/run/docker.sock:/var/run/docker.sock image-with-python-on-whales\n</code></pre> <p>You should see this output:</p> <pre><code>We are going to run the hello world docker container\nHere is the output:\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https://hub.docker.com/\n\nFor more examples and ideas, visit:\n https://docs.docker.com/get-started/\n\nbuildx version: github.com/docker/buildx v0.6.3 266c0eac611d64fcc0c72d80206aa364e826758d\ncompose version: Docker Compose version v2.0.0-rc.2\n</code></pre>"},{"location":"user_guide/running_python_on_whales_inside_a_container/#how-does-it-work","title":"How does it work?","text":"<p>The main magic here is the sharing of the docker socket between the host and the container. This is done with the <code>-v /var/run/docker.sock:/var/run/docker.sock</code>.</p> <p>With this option, the container can have access to the docker API. But it still needs the binary client in Go. Download it in the dockerfile with <code>python-no-whales download-cli</code>. You can then optionally install buildx and compose.</p> <p>Then you're good to go! Simple as that.</p>"}]}